import { LitElement, html, css, nothing } from 'lit';
import { customElement, property, state } from 'lit/decorators.js';
import { HomeAssistant, fireEvent } from 'custom-card-helpers';
import {
  UltraVehicleCardConfig,
  BarConfig,
  IconConfig,
  IconRowConfig,
  ImageCropSettings,
} from './types';
import './components/entity-picker';
import './components/color-picker';
import { uploadImage } from './utils/image-upload';
import memoizeOne from 'memoize-one';

// Define schema types
interface SchemaBase {
  name?: string;
  label?: string;
  description?: string;
}

interface SelectOption {
  value: string;
  label: string;
}

interface SchemaSelector extends SchemaBase {
  selector:
    | { text: Record<string, unknown> }
    | { entity: Record<string, unknown> }
    | { boolean: Record<string, unknown> }
    | { select: { options: SelectOption[]; mode?: string } }
    | { color: { type: string } }
    | { color_rgb: Record<string, unknown> }
    | { number: { min?: number; max?: number; step?: number; unit?: string; mode?: string } };
  description?: string;
}

interface SchemaSectionHeader extends SchemaBase {
  type: 'section';
  label: string;
}

type SchemaItem = SchemaSelector | SchemaSectionHeader;

// Schema definitions
const IMAGE_TYPE_OPTIONS = [
  { value: 'none', label: 'None' },
  { value: 'default', label: 'Default' },
  { value: 'upload', label: 'Upload' },
  { value: 'url', label: 'URL' },
  { value: 'entity', label: 'Entity' },
];

const LAYOUT_TYPE_OPTIONS = [
  { value: 'single', label: 'Single Column' },
  { value: 'double', label: 'Two Columns' },
];

const BAR_SIZE_OPTIONS = [
  { value: 'thin', label: 'Thin' },
  { value: 'regular', label: 'Regular' },
  { value: 'thick', label: 'Thick' },
  { value: 'thiccc', label: 'Extra Thick' },
];

// Define bar width options
const BAR_WIDTH_OPTIONS = [
  { value: '100', label: '100% (Full Width)' },
  { value: '75', label: '75% Width' },
  { value: '50', label: '50% Width' },
  { value: '25', label: '25% Width' },
];

// Define animation options
const BAR_ANIMATION_OPTIONS = [
  { value: 'charging_lines', label: 'Charging Lines' },
  { value: 'fill_repeat', label: 'Fill & Repeat' },
  { value: 'pulse', label: 'Pulse' },
  { value: 'glow', label: 'Glow' },
  { value: 'rainbow', label: 'Rainbow Colors' },
];

// Define constants for the SVG paths to prevent typos and inconsistencies
const ICON_PATH_EXPAND = 'M7.41,8.58L12,13.17L16.59,8.58L18,10L12,16L6,10L7.41,8.58Z';
const ICON_PATH_COLLAPSE = 'M7.41,15.41L12,10.83L16.59,15.41L18,14L12,8L6,14L7.41,15.41Z';
const ICON_PATH_DELETE =
  'M19,4H15.5L14.5,3H9.5L8.5,4H5V6H19M6,19A2,2 0 0,0 8,21H16A2,2 0 0,0 18,19V7H6V19Z';

// Define default colors
const DEFAULT_COLORS = {
  bar_color: '#3498db',
  background_color: '#e0e0e0',
  border_color: '#cccccc',
  left_title_color: 'var(--text-primary-color, #777777)',
  left_text_color: 'var(--text-primary-color, #000000)',
  right_title_color: 'var(--text-primary-color, #777777)',
  right_text_color: 'var(--text-primary-color, #000000)',
  limit_indicator_color: '#ff0000',
};

// Update the DEFAULT_BAR_CONFIG with proper typing
const DEFAULT_BAR_CONFIG: BarConfig = {
  entity: '',
  left_title: '',
  left_entity: '',
  right_title: '',
  right_entity: '',
  bar_color: DEFAULT_COLORS.bar_color,
  background_color: DEFAULT_COLORS.background_color,
  border_color: DEFAULT_COLORS.border_color,
  left_title_color: DEFAULT_COLORS.left_title_color,
  left_text_color: DEFAULT_COLORS.left_text_color,
  right_title_color: DEFAULT_COLORS.right_title_color,
  right_text_color: DEFAULT_COLORS.right_text_color,
  limit_indicator_color: DEFAULT_COLORS.limit_indicator_color,
  bar_size: 'regular', // This should be one of the allowed values
  show_left: true,
  show_right: true,
  alignment: 'space-between',
  width: '100',
  use_gradient: false,
  gradient_stops: [
    { id: 'stop1', position: 0, color: '#ff0000' }, // Red
    { id: 'stop2', position: 50, color: '#ffff00' }, // Yellow
    { id: 'stop3', position: 100, color: '#00ff00' }, // Green
  ],
  animation_entity: '',
  animation_state: '',
  animation_type: 'charging_lines',
};

// Default configuration for clean YAML output reference
const DEFAULT_CONFIG = {
  vehicle_image_type: 'none',
  status_image_type: 'none',
  layout_type: 'single',
  formatted_entities: false,
  vehicle_image_width: 100, // Set default image width to 100%
  action_image_width: 100, // Set default action image width to 100% as well
};

// Compute schema for the settings tab with proper types
const computeSettingsSchema = memoizeOne((imageType): any[] => {
  const schema: any[] = [
    {
      name: 'title',
      selector: { text: {} },
      label: 'Card Title',
    },
    {
      name: 'vehicle_image_type',
      selector: {
        select: {
          options: IMAGE_TYPE_OPTIONS,
          mode: 'dropdown',
        },
      },
      label: 'Vehicle Image Type',
    },
    // Only add URL field if URL type is selected
    ...(imageType === 'url'
      ? [
          {
            name: 'vehicle_image',
            selector: { text: {} },
            label: 'Image URL',
          },
        ]
      : []),
    // Only add entity picker if entity type is selected
    ...(imageType === 'entity'
      ? [
          {
            name: 'vehicle_image_entity',
            selector: { entity: {} },
            label: 'Image Entity',
          },
        ]
      : []),
    {
      name: 'layout_type',
      selector: {
        select: {
          options: LAYOUT_TYPE_OPTIONS,
          mode: 'dropdown',
        },
      },
      label: 'Layout Style',
    },
    {
      name: 'formatted_entities',
      selector: { boolean: {} },
      label: 'Format Entities',
      description:
        'Clean up entity values by rounding numbers, replacing underscores with spaces, capitalizing words, and adding commas to large numbers.',
    },
    {
      name: 'show_units',
      selector: { boolean: {} },
      label: 'Show Units of Measurement',
      description: 'Display units, currencies, and other formatting from entity attributes.',
    },
  ];

  // Vehicle info fields
  schema.push(
    {
      type: 'section',
      label: 'Vehicle Information',
    },
    {
      name: 'location_entity',
      selector: { entity: {} },
      label: 'Location Entity',
      description: 'Select the entity that provides the current location of your vehicle.',
    },
    {
      name: 'show_location',
      selector: { boolean: {} },
      label: 'Show Location',
    },
    {
      name: 'mileage_entity',
      selector: { entity: {} },
      label: 'Mileage Entity',
      description:
        'Select the entity that represents the total mileage or odometer reading of your vehicle.',
    },
    {
      name: 'show_mileage',
      selector: { boolean: {} },
      label: 'Show Mileage',
    },
    {
      name: 'car_state_entity',
      selector: { entity: {} },
      label: 'Car State Entity',
      description:
        'Select the entity that represents the current state of your vehicle (e.g., parked, driving, charging).',
    },
    {
      name: 'show_car_state',
      selector: { boolean: {} },
      label: 'Show Car State',
    }
  );

  return schema;
});

// Compute schema for a bar with proper types
const computeBarSchema = memoizeOne((index): any[] => {
  return [
    {
      name: `bars.${index}.entity`,
      selector: { entity: {} },
      label: 'Bar Percentage Entity',
      description:
        'Select an entity that returns a percentage value (0-100). This controls the fill of the bar.',
    },
    {
      name: `bars.${index}.limit_entity`,
      selector: { entity: {} },
      label: 'Limit Entity (optional)',
      description: 'Optional: Add a limit indicator on the bar (e.g., charge limit for EV).',
    },
    {
      name: `bars.${index}.bar_size`,
      selector: {
        select: {
          options: BAR_SIZE_OPTIONS,
          mode: 'dropdown',
        },
      },
      label: 'Bar Size',
      description: 'Select the height of the progress bar.',
    },
    {
      name: `bars.${index}.width`,
      selector: {
        select: {
          options: BAR_WIDTH_OPTIONS,
          mode: 'dropdown',
        },
      },
      label: 'Bar Width',
      description:
        'Select the width of the bar. Multiple bars with partial widths will be placed side by side if possible.',
    },
    {
      type: 'section',
      label: 'Left Side',
    },
    {
      name: `bars.${index}.left_title`,
      selector: { text: {} },
      label: 'Left Title',
    },
    {
      name: `bars.${index}.left_entity`,
      selector: { entity: {} },
      label: 'Left Entity',
    },
    {
      type: 'section',
      label: 'Right Side',
    },
    {
      name: `bars.${index}.right_title`,
      selector: { text: {} },
      label: 'Right Title',
    },
    {
      name: `bars.${index}.right_entity`,
      selector: { entity: {} },
      label: 'Right Entity',
    },
    {
      type: 'section',
      label: 'Colors',
    },
    {
      name: `bars.${index}.bar_color`,
      selector: { color_rgb: {} },
      label: 'Bar Color',
      description: `Default: ${DEFAULT_COLORS.bar_color}`,
    },
    {
      name: `bars.${index}.background_color`,
      selector: { color_rgb: {} },
      label: 'Background Color',
      description: `Default: ${DEFAULT_COLORS.background_color}`,
    },
    {
      name: `bars.${index}.border_color`,
      selector: { color_rgb: {} },
      label: 'Border Color',
      description: `Default: ${DEFAULT_COLORS.border_color}`,
    },
    {
      name: `bars.${index}.left_title_color`,
      selector: { color_rgb: {} },
      label: 'Left Title Color',
      description: `Default: ${DEFAULT_COLORS.left_title_color}`,
    },
    {
      name: `bars.${index}.left_text_color`,
      selector: { color_rgb: {} },
      label: 'Left Value Color',
      description: `Default: ${DEFAULT_COLORS.left_text_color}`,
    },
    {
      name: `bars.${index}.right_title_color`,
      selector: { color_rgb: {} },
      label: 'Right Title Color',
      description: `Default: ${DEFAULT_COLORS.right_title_color}`,
    },
    {
      name: `bars.${index}.right_text_color`,
      selector: { color_rgb: {} },
      label: 'Right Value Color',
      description: `Default: ${DEFAULT_COLORS.right_text_color}`,
    },
  ];
});

// Add these constants for icon configuration

const ICON_ROW_WIDTH_OPTIONS = [
  { value: '100', label: '100% (Full Width)' },
  { value: '75', label: '75% Width' },
  { value: '50', label: '50% Width' },
  { value: '25', label: '25% Width' },
];

const ICON_ALIGNMENT_OPTIONS = [
  { value: 'flex-start', label: 'Left' },
  { value: 'center', label: 'Center' },
  { value: 'flex-end', label: 'Right' },
  { value: 'space-between', label: 'Space Between' },
  { value: 'space-around', label: 'Space Around' },
  { value: 'space-evenly', label: 'Space Evenly' },
];

const ICON_SPACING_OPTIONS = [
  { value: 'none', label: 'None' },
  { value: 'small', label: 'Small' },
  { value: 'medium', label: 'Medium' },
  { value: 'large', label: 'Large' },
];

const ICON_ACTION_OPTIONS = [
  { value: 'toggle', label: 'Toggle Entity' },
  { value: 'more-info', label: 'Show More Info' },
  { value: 'call-service', label: 'Call Service' },
  { value: 'none', label: 'No Action' },
];

// Add these title alignment options near the top of the file with other constants
const TITLE_ALIGNMENT_OPTIONS = [
  { value: 'left', label: 'Left' },
  { value: 'center', label: 'Center' },
  { value: 'right', label: 'Right' },
];

// Add these new constants for icon text alignment and size options
const ICON_TEXT_POSITION_OPTIONS = [
  { value: 'bottom', label: 'Bottom' },
  { value: 'top', label: 'Top' },
  { value: 'left', label: 'Left' },
  { value: 'right', label: 'Right' },
];

const ICON_VERTICAL_ALIGNMENT_OPTIONS = [
  { value: 'flex-start', label: 'Top' },
  { value: 'center', label: 'Center' },
  { value: 'flex-end', label: 'Bottom' },
];

const ICON_SIZE_OPTIONS = [
  { value: 'small', label: 'Small' },
  { value: 'medium', label: 'Medium' },
  { value: 'large', label: 'Large' },
];

const TEXT_SIZE_OPTIONS = [
  { value: 'small', label: 'Small' },
  { value: 'medium', label: 'Medium' },
  { value: 'large', label: 'Large' },
];

@customElement('ultra-vehicle-card-editor')
export class UltraVehicleCardEditor extends LitElement {
  @property({ attribute: false }) public hass!: HomeAssistant;
  @property() private config!: UltraVehicleCardConfig;
  @state() private activeTab: string = 'settings';
  @state() private _showEntityList: boolean = false;
  @state() private _activeField: string = '';
  @state() private _entityFilter: string = '';
  @state() private _entities: any[] = [];
  @state() private _expandedBar: number | null = null;
  @state() private _preventExpandCollapse: boolean = false;
  @state() private _draggedBarIndex: number | null = null;
  @state() private _dropTargetIndex: number | null = null;
  @state() private _expandedIconRow: string | null = null;
  @state() private _expandedIcon: { rowId: string; iconIndex: number } | null = null;
  @state() private _draggedIconRow: string | null = null;
  @state() private _draggedIcon: { rowId: string; iconIndex: number } | null = null;
  @state() private _dropTargetRow: string | null = null;
  @state() private _dropTargetIcon: { rowId: string; iconIndex: number } | null = null;
  @state() private _cropperActive: boolean = false;
  @state() private _cropperImage: string = '';
  @state() private _cropperTargetField: string = '';
  @state() private _vehicleCropExpanded: boolean = false;
  @state() private _actionCropExpanded: boolean = false;
  @property() private _draggedBar = null;
  @property() private _dropTargetBar = null;
  @property() private _dropTargetIconRow = null;
  @state() private _draggedSection: number | null = null;
  private _editorVersion = '1.2.0-debug'; // Add version to help with debugging

  setConfig(config: UltraVehicleCardConfig) {
    if (!config) {
      throw new Error('Invalid configuration');
    }

    console.log(`[EDITOR VERSION] Ultra Vehicle Card Editor v${this._editorVersion}`);

    // Create a new config object with our defaults
    this.config = {
      // Default values
      vehicle_image_type: 'default',
      status_image_type: 'none',
      layout_type: 'single',
      formatted_entities: false,
      show_location: true,
      show_mileage: true,
      show_car_state: true,
      sections_order: ['title', 'image', 'info'],
      bars: [],
      icon_rows: [],
      // Override with user config
      ...config,
    };

    // If existing sections_order doesn't have info, add it after image
    if (this.config.sections_order && !this.config.sections_order.includes('info')) {
      // Create a new array to avoid modifying a potentially frozen array
      const newSectionsOrder = [...this.config.sections_order];

      const imageIndex = newSectionsOrder.indexOf('image');
      if (imageIndex !== -1) {
        // Add info after image
        newSectionsOrder.splice(imageIndex + 1, 0, 'info');
      } else {
        // Add info at the beginning if image not found
        newSectionsOrder.unshift('info');
      }

      // Update the config with the new array
      this.config.sections_order = newSectionsOrder;
    }

    // If width values are missing, set defaults separately
    if (this.config.vehicle_image_width === undefined) {
      this.config.vehicle_image_width = 100;
    }

    if (this.config.action_image_width === undefined) {
      this.config.action_image_width = 100;
    }

    // Convert existing bar and icon sections to individual sections if needed
    this._migrateToIndividualSections();
  }

  private _migrateToIndividualSections() {
    if (!this.config.sections_order) return;

    // Make a copy of the sections order to modify
    let updatedSectionsOrder = [...this.config.sections_order];
    let changed = false;

    // Handle 'bars' section
    const barsIndex = updatedSectionsOrder.indexOf('bars');
    if (barsIndex !== -1 && this.config.bars && this.config.bars.length > 0) {
      // Check if there are already bar_X sections - if so, don't migrate
      const hasIndividualBarSections = updatedSectionsOrder.some(section =>
        section.startsWith('bar_')
      );

      if (!hasIndividualBarSections) {
        // Replace 'bars' with individual bar sections
        const barSections = this.config.bars.map((_, idx) => `bar_${idx}`);
        updatedSectionsOrder.splice(barsIndex, 1, ...barSections);
        changed = true;
      }
    }

    // Handle 'icons' section
    const iconsIndex = updatedSectionsOrder.indexOf('icons');
    if (iconsIndex !== -1 && this.config.icon_rows && this.config.icon_rows.length > 0) {
      // Check if there are already icon_row_X sections - if so, don't migrate
      const hasIndividualIconSections = updatedSectionsOrder.some(section =>
        section.startsWith('icon_row_')
      );

      if (!hasIndividualIconSections) {
        // Replace 'icons' with individual icon row sections
        const iconRowSections = this.config.icon_rows.map(row => `icon_row_${row.id}`);
        updatedSectionsOrder.splice(iconsIndex, 1, ...iconRowSections);
        changed = true;
      }
    }

    // Update config if changes were made
    if (changed) {
      this.config.sections_order = updatedSectionsOrder;
    }
  }

  private async handleFileUpload(ev: Event, configKey: string) {
    const input = ev.target as HTMLInputElement;
    const file = input.files?.[0];

    if (file) {
      try {
        console.log('[UPLOAD DEBUG] Starting upload to Home Assistant API for', configKey);

        // Use the uploadImage utility function
        const { uploadImage } = await import('./utils/image-upload');
        const result = await uploadImage(this.hass, file);

        if (!result.success) {
          throw new Error(result.error || 'Failed to upload image');
        }

        console.log('[UPLOAD DEBUG] Upload successful, path:', result.path);

        // Update the config with the proper path
        this._updateConfig({
          [configKey]: result.path,
        });
      } catch (error) {
        console.error('[UPLOAD DEBUG] Error uploading file:', error);
        alert(
          'Failed to upload image. Please try again or upload the image manually to the Media Library.'
        );
      }
    }
  }

  private _getCleanConfig(): UltraVehicleCardConfig {
    // Create a shallow copy of the config
    const cleanConfig = { ...this.config };

    // Process bars to ensure they're ordered consistently and have clean properties
    if (cleanConfig.bars && cleanConfig.bars.length > 0) {
      cleanConfig.bars = cleanConfig.bars.map(bar => {
        // Create a new bar object with the required entity property first (to ensure it's always included)
        const cleanBar: BarConfig = {
          entity: bar.entity, // This is required by the BarConfig interface
          // Optional properties with defaults if missing
          bar_size: bar.bar_size || 'regular',
          width: bar.width || '100',
          bar_color: bar.bar_color || DEFAULT_COLORS.bar_color,
          background_color: bar.background_color || DEFAULT_COLORS.background_color,
          border_color: bar.border_color || DEFAULT_COLORS.border_color,
          left_title_color: bar.left_title_color || DEFAULT_COLORS.left_title_color,
          left_text_color: bar.left_text_color || DEFAULT_COLORS.left_text_color,
          right_title_color: bar.right_title_color || DEFAULT_COLORS.right_title_color,
          right_text_color: bar.right_text_color || DEFAULT_COLORS.right_text_color,
          alignment: bar.alignment || 'space-between',
          show_left: bar.show_left,
          show_right: bar.show_right,
        };

        // Add optional properties only if they exist
        if (bar.limit_entity) cleanBar.limit_entity = bar.limit_entity;
        if (bar.left_title) cleanBar.left_title = bar.left_title;
        if (bar.left_entity) cleanBar.left_entity = bar.left_entity;
        if (bar.right_title) cleanBar.right_title = bar.right_title;
        if (bar.right_entity) cleanBar.right_entity = bar.right_entity;

        return cleanBar;
      });
    }

    // Remove empty arrays
    if (cleanConfig.bars && cleanConfig.bars.length === 0) {
      delete cleanConfig.bars;
    }

    // Remove undefined or default properties
    ['vehicle_image_type', 'status_image_type', 'layout_type', 'formatted_entities'].forEach(
      prop => {
        if (cleanConfig[prop] === DEFAULT_CONFIG[prop]) {
          delete cleanConfig[prop];
        }
      }
    );

    return cleanConfig;
  }

  private _updateConfig(updates: Partial<UltraVehicleCardConfig>) {
    const newConfig = {
      ...(this.config || {}),
      ...updates,
    } as UltraVehicleCardConfig;

    if (updates.vehicle_image_type) {
      if (updates.vehicle_image_type !== this.config.vehicle_image_type) {
        delete newConfig.vehicle_image;
        delete newConfig.vehicle_image_entity;
      }
      console.log('Image config update:', {
        type: updates.vehicle_image_type,
        image: newConfig.vehicle_image ? 'present' : 'missing',
        entity: newConfig.vehicle_image_entity,
      });
    }

    if (updates.status_image_type) {
      if (updates.status_image_type !== this.config.status_image_type) {
        delete newConfig.status_image;
        delete newConfig.status_image_entity;
        delete newConfig.status_image_trigger_entity;
      }
    }

    this.config = newConfig;

    this.requestUpdate();

    // Before dispatching the event, clean the config
    const cleanConfig = this._getCleanConfig();

    const event = new CustomEvent('config-changed', {
      detail: { config: cleanConfig },
      bubbles: true,
      composed: true,
      cancelable: true,
    });
    this.dispatchEvent(event);
  }

  private _valueChanged(ev: CustomEvent): void {
    const config = ev.detail.value;
    fireEvent(this, 'config-changed', { config });
  }

  private _barValueChanged(ev: CustomEvent, index: number): void {
    ev.stopPropagation();

    // Create a deep copy of the config
    const newConfig = JSON.parse(JSON.stringify(this.config));
    if (!newConfig.bars || !newConfig.bars[index]) return;

    // Extract bar data from event
    const prefix = `bars.${index}.`;
    let gradientToggled = false;
    const oldUseGradient = newConfig.bars[index].use_gradient;

    if (ev.detail && ev.detail.value) {
      Object.entries(ev.detail.value).forEach(([key, value]) => {
        if (key.startsWith(prefix)) {
          const barProp = key.substring(prefix.length);

          // Check if gradient was toggled on
          if (barProp === 'use_gradient') {
            gradientToggled = value === true && !oldUseGradient;
            // Keep track of gradient mode state
            newConfig.bars[index].use_gradient = value;
          }

          // Special handling for color values
          if (barProp.includes('color')) {
            // Convert color values to proper CSS format
            if (Array.isArray(value)) {
              // If it's an RGB array [r, g, b]
              newConfig.bars[index][barProp] = `rgb(${value.join(', ')})`;
            } else if (typeof value === 'object' && value !== null) {
              // If it's an object with r, g, b properties
              if ('r' in value && 'g' in value && 'b' in value) {
                newConfig.bars[index][barProp] = `rgb(${value.r}, ${value.g}, ${value.b})`;
              } else if (value.toString) {
                // If it has a toString method
                newConfig.bars[index][barProp] = value.toString();
              } else {
                // Fallback
                newConfig.bars[index][barProp] = value;
              }
            } else {
              // If it's already a string like "#ff0000"
              newConfig.bars[index][barProp] = value;
            }
          } else {
            // For non-color properties
            newConfig.bars[index][barProp] = value;
          }
        }
      });
    }

    // If gradient was toggled on, ensure default gradient stops exist
    if (gradientToggled) {
      this._ensureGradientStops(newConfig.bars[index]);
    }

    // Dispatch event
    fireEvent(this, 'config-changed', { config: newConfig });

    // Force update UI
    this.requestUpdate();
  }

  // Add a helper function to ensure gradient stops are initialized
  private _ensureGradientStops(bar: BarConfig): void {
    if (!bar.gradient_stops || bar.gradient_stops.length < 2) {
      // Initialize with default gradient stops with unique IDs
      bar.gradient_stops = [
        { id: this._generateUniqueId(), position: 0, color: '#ff0000' }, // Red
        { id: this._generateUniqueId(), position: 50, color: '#ffff00' }, // Yellow
        { id: this._generateUniqueId(), position: 100, color: '#00ff00' }, // Green
      ];
    } else {
      // Make sure all stops have an ID
      bar.gradient_stops = bar.gradient_stops.map(stop => {
        if (!stop.id) {
          return {
            ...stop,
            id: this._generateUniqueId(),
          };
        }
        return stop;
      });
    }
  }

  private _toggleBarExpand(index: number) {
    if (this._preventExpandCollapse) {
      this._preventExpandCollapse = false;
      return;
    }

    this._expandedBar = this._expandedBar === index ? null : index;
  }

  private _addBar() {
    const bars = [...(this.config.bars || [])];
    // Create a deep copy of DEFAULT_BAR_CONFIG to ensure all default colors are applied
    const newBar = JSON.parse(JSON.stringify(DEFAULT_BAR_CONFIG));
    bars.push(newBar);

    // Update the sections_order to include the new bar
    const sectionsOrder = [...(this.config.sections_order || ['title', 'image', 'info'])];

    // Check if we're using the legacy section format (with 'bars') or individual bars
    const usesLegacyFormat = sectionsOrder.includes('bars');
    const hasIndividualBars = sectionsOrder.some(section => section.startsWith('bar_'));

    if (usesLegacyFormat) {
      // Already using legacy format, no need to modify sections_order
    } else if (hasIndividualBars) {
      // Using individual bar sections, add a new one
      const newBarSectionId = `bar_${bars.length - 1}`;
      sectionsOrder.push(newBarSectionId);
    } else {
      // Using neither format, add the legacy 'bars' section for compatibility
      sectionsOrder.push('bars');
    }

    fireEvent(this, 'config-changed', {
      config: {
        ...this.config,
        bars,
        sections_order: sectionsOrder,
      },
    });

    this._expandedBar = bars.length - 1;
  }

  private _removeBar(index: number) {
    const bars = [...(this.config.bars || [])];
    bars.splice(index, 1);

    // Update sections_order to remove the bar section
    const sectionsOrder = [...(this.config.sections_order || [])];
    const barSectionId = `bar_${index}`;
    const barSectionIndex = sectionsOrder.indexOf(barSectionId);

    if (barSectionIndex !== -1) {
      sectionsOrder.splice(barSectionIndex, 1);
    }

    // Rename bar sections with higher indices
    for (let i = 0; i < sectionsOrder.length; i++) {
      const section = sectionsOrder[i];
      if (section.startsWith('bar_')) {
        const barIdx = parseInt(section.substring(4));
        if (barIdx > index) {
          // Update the index in the section ID
          sectionsOrder[i] = `bar_${barIdx - 1}`;
        }
      }
    }

    fireEvent(this, 'config-changed', {
      config: {
        ...this.config,
        bars,
        sections_order: sectionsOrder,
      },
    });

    if (this._expandedBar === index) {
      this._expandedBar = null;
    } else if (this._expandedBar !== null && this._expandedBar > index) {
      this._expandedBar = this._expandedBar - 1;
    }
  }

  private _renderSettingsTab() {
    // Basic settings schema - Title
    const titleSchema = [
      {
        name: 'title',
        selector: { text: {} },
        label: 'Card Title',
        description: 'The title displayed at the top of the card. Leave empty for no title.',
      },
      {
        name: 'title_alignment',
        selector: {
          select: {
            options: TITLE_ALIGNMENT_OPTIONS,
            mode: 'dropdown',
          },
        },
        label: 'Title Alignment',
        description: 'Control how the title is aligned on the card (left, center, or right).',
      },
      {
        name: 'formatted_entities',
        selector: { boolean: {} },
        label: 'Format Entities',
        description:
          'Improves the display of entity values by rounding numbers, replacing underscores with spaces, capitalizing words, and adding commas to large numbers.',
      },
    ];

    // Image section schema - Only Vehicle Image Type initially
    const imageSchema = [
      {
        name: 'vehicle_image_type',
        selector: {
          select: {
            options: IMAGE_TYPE_OPTIONS,
            mode: 'dropdown',
          },
        },
        label: 'Vehicle Image Type',
        description:
          'Select how to display the vehicle image: Default (built-in), Local (upload), URL (external link), Entity (from Home Assistant), or None.',
      },
    ];

    // Add URL field if URL type is selected
    if (this.config.vehicle_image_type === 'url') {
      imageSchema.push({
        name: 'vehicle_image',
        selector: { text: {} } as any,
        label: 'Image URL',
        description: 'Enter the full URL to an image of your vehicle.',
      });
    }

    // Add URL field for Home Assistant Image API URLs

    // Add entity picker if entity type is selected
    if (this.config.vehicle_image_type === 'entity') {
      imageSchema.push({
        name: 'vehicle_image_entity',
        selector: { entity: {} } as any,
        label: 'Image Entity',
        description: 'Select an entity that returns an image URL for your vehicle.',
      });
    }

    // Add image width slider if vehicle image type is not "none"
    if (this.config.vehicle_image_type && this.config.vehicle_image_type !== 'none') {
      imageSchema.push({
        name: 'vehicle_image_width',
        selector: {
          number: {
            min: 0,
            max: 100,
            step: 1,
            unit: '%',
            mode: 'slider',
          },
        },
        label: 'Image Width',
        description:
          'Set the width of the vehicle image as a percentage of the card width. Height will adjust automatically to maintain proportions.',
      } as any);
    }

    // Entity settings schema
    const entitySchema = [
      {
        type: 'section',
        label: 'Vehicle Information',
      },
      {
        name: 'show_location',
        selector: { boolean: {} },
        label: 'Show Location',
        description: 'Display the current location of your vehicle on the card.',
      },
      {
        name: 'location_entity',
        selector: { entity: {} },
        label: 'Location Entity',
        description: 'Select the entity that provides the current location of your vehicle.',
      },
      {
        name: 'show_mileage',
        selector: { boolean: {} },
        label: 'Show Mileage',
        description: 'Display the odometer reading or mileage information on the card.',
      },
      {
        name: 'mileage_entity',
        selector: { entity: {} },
        label: 'Mileage Entity',
        description:
          'Select the entity that represents the total mileage or odometer reading of your vehicle.',
      },
      {
        name: 'show_car_state',
        selector: { boolean: {} },
        label: 'Show Car State',
        description: 'Display the current state of your vehicle (e.g., parked, driving, charging).',
      },
      {
        name: 'car_state_entity',
        selector: { entity: {} },
        label: 'Car State Entity',
        description: 'Select the entity that represents the current state of your vehicle.',
      },
    ];

    return html`
      <div class="tab-content">
        <!-- Basic Settings Section - Title on top -->
        <div class="settings-section">
          <div class="section-header">Basic Settings</div>
          <div class="settings-content">
            <ha-form
              class="config-form title-form"
              .hass=${this.hass}
              .data=${this.config}
              .schema=${titleSchema}
              .computeLabel=${schema => schema.label || schema.name}
              .computeDescription=${schema => schema.description}
              @value-changed=${this._valueChanged}
            ></ha-form>
          </div>
        </div>

        <!-- Image Settings Section -->
        <div class="settings-section">
          <div class="section-header">Image Settings</div>
          <div class="settings-content">
            <!-- Vehicle Image Type Dropdown -->
            <ha-form
              class="config-form image-type-form"
              .hass=${this.hass}
              .data=${this.config}
              .schema=${[
                {
                  name: 'vehicle_image_type',
                  selector: {
                    select: {
                      options: IMAGE_TYPE_OPTIONS,
                      mode: 'dropdown',
                    },
                  },
                  label: 'Vehicle Image Type',
                  description:
                    'Select how to display the vehicle image: Default (built-in), Local (upload), URL (external link), Entity (from Home Assistant), or None.',
                },
              ]}
              .computeLabel=${schema => schema.label || schema.name}
              .computeDescription=${schema => schema.description}
              @value-changed=${this._valueChanged}
            ></ha-form>

            <!-- Upload Vehicle Image immediately after dropdown if upload type is selected -->
            ${this.config.vehicle_image_type === 'upload'
              ? html`
                  <div class="upload-container">
                    <label>Upload Vehicle Image</label>
                    <input
                      type="file"
                      accept="image/*"
                      @change=${this._handleFileInputChange}
                      style="width: 100%; margin-top: 8px; margin-bottom: 16px;"
                    />
                  </div>
                `
              : ''}

            <!-- URL field if URL type is selected -->
            ${this.config.vehicle_image_type === 'url'
              ? html`
                  <ha-form
                    class="config-form image-url-form"
                    .hass=${this.hass}
                    .data=${this.config}
                    .schema=${[
                      {
                        name: 'vehicle_image',
                        selector: { text: {} },
                        label: 'Image URL',
                        description: 'Enter the full URL to an image of your vehicle.',
                      },
                    ]}
                    .computeLabel=${schema => schema.label || schema.name}
                    .computeDescription=${schema => schema.description}
                    @value-changed=${this._valueChanged}
                  ></ha-form>
                `
              : ''}

            <!-- Entity picker if entity type is selected -->
            ${this.config.vehicle_image_type === 'entity'
              ? html`
                  <ha-form
                    class="config-form image-entity-form"
                    .hass=${this.hass}
                    .data=${this.config}
                    .schema=${[
                      {
                        name: 'vehicle_image_entity',
                        selector: { entity: {} },
                        label: 'Image Entity',
                        description: 'Select an entity that returns an image URL for your vehicle.',
                      },
                    ]}
                    .computeLabel=${schema => schema.label || schema.name}
                    .computeDescription=${schema => schema.description}
                    @value-changed=${this._valueChanged}
                  ></ha-form>
                `
              : ''}

            <!-- Add image width slider if vehicle image type is not "none" - This is separate from the upload -->
            ${this.config.vehicle_image_type && this.config.vehicle_image_type !== 'none'
              ? html`
                  <ha-form
                    class="config-form image-width-form"
                    .hass=${this.hass}
                    .data=${this.config}
                    .schema=${[
                      {
                        name: 'vehicle_image_width',
                        selector: {
                          number: {
                            min: 0,
                            max: 100,
                            step: 1,
                            unit: '%',
                            mode: 'slider',
                          },
                        },
                        label: 'Image Width',
                        description:
                          'Set the width of the vehicle image as a percentage of the card width. Height will adjust automatically to maintain proportions.',
                      },
                    ]}
                    .computeLabel=${schema => schema.label || schema.name}
                    .computeDescription=${schema => schema.description}
                    @value-changed=${this._valueChanged}
                  ></ha-form>
                `
              : ''}

            <!-- Image crop controls as a separate element at the bottom -->
            ${this.config.vehicle_image_type === 'upload'
              ? html`
                  <div class="crop-accordion">
                    <div
                      class="crop-accordion-header"
                      @click=${() => {
                        this._vehicleCropExpanded = !this._vehicleCropExpanded;
                        this.requestUpdate();
                      }}
                    >
                      <span>Image Crop</span>
                      <ha-icon
                        icon="${this._vehicleCropExpanded ? 'mdi:chevron-up' : 'mdi:chevron-down'}"
                      ></ha-icon>
                    </div>

                    ${this._vehicleCropExpanded
                      ? html`
                          <div class="crop-controls">
                            ${this._renderCropSliders('vehicle_image_crop')}
                          </div>
                        `
                      : ''}
                  </div>
                `
              : ''}

            <!-- Action Entity -->
            <ha-form
              class="config-form action-entity-form"
              .hass=${this.hass}
              .data=${this.config}
              .schema=${[
                {
                  name: 'action_entity',
                  selector: { entity: {} },
                  label: 'Action Entity',
                  description: 'Entity that triggers different vehicle images based on its state.',
                } as any,
              ]}
              .computeLabel=${schema => schema.label || schema.name}
              .computeDescription=${schema => schema.description}
              @value-changed=${this._valueChanged}
            ></ha-form>

            <!-- Action State and Action Image Settings (if action entity is selected) -->
            ${this.config.action_entity ? this._renderActionSchema(this.config.action_entity) : ''}
          </div>
        </div>

        <!-- Entity Settings Section -->
        <div class="settings-section">
          <div class="section-header">Entity Settings</div>
          <div class="settings-content">
            <ha-form
              class="config-form entity-form"
              .hass=${this.hass}
              .data=${this.config}
              .schema=${entitySchema}
              .computeLabel=${schema => schema.label || schema.name}
              .computeDescription=${schema => schema.description}
              @value-changed=${this._valueChanged}
            ></ha-form>
          </div>
        </div>
      </div>
    `;
  }

  private _renderCustomizeTab() {
    // Layout style schema
    const layoutSchema = [
      {
        name: 'layout_type',
        selector: {
          select: {
            options: LAYOUT_TYPE_OPTIONS,
            mode: 'dropdown',
          },
        },
        label: 'Layout Style',
        description: 'Choose between single column or two-column layout for the card',
      },
    ];

    return html`
      <div class="tab-content">
        <div class="settings-section">
          <div class="section-header">Layout Settings</div>
          <div class="settings-content">
            <ha-form
              class="config-form layout-form"
              .hass=${this.hass}
              .data=${this.config}
              .schema=${layoutSchema}
              .computeLabel=${schema => schema.label || schema.name}
              .computeDescription=${schema => schema.description}
              @value-changed=${this._valueChanged}
            ></ha-form>
          </div>
        </div>

        <div class="settings-section">
          <div class="section-header">Card Sections</div>
          <div class="settings-content">
            <h4>Section Arrangement</h4>
            <p>
              Drag and drop sections to arrange their order on the card.
              ${this.config.layout_type === 'double'
                ? 'In two-column layout, you can place all sections in either column.'
                : 'All sections will display in a single column.'}
            </p>

            <div class="sections-container">${this._renderDraggableSections()}</div>
          </div>
        </div>
      </div>
    `;
  }

  private _renderBarsTab() {
    return html`
      <div class="tab-content">
        <div class="section-header">Percentage Bars</div>

        <div class="bars-description">
          Add percentage bars to display values like fuel level, battery charge, or range. Each bar
          can display a main percentage value with optional left and right labels.
        </div>

        <div class="bars-container">
          ${this.config.bars?.map((bar, index) => this._renderBar(bar, index)) || ''}
        </div>

        <div class="add-bar-container">
          <ha-button class="add-bar-button" @click=${this._addBar}>
            <ha-icon icon="mdi:plus" class="add-icon"></ha-icon>
            Add New Bar
          </ha-button>
        </div>
      </div>
    `;
  }

  private _truncateText(text: string, maxLength: number = 15): string {
    if (!text) return '';
    if (text.length <= maxLength) return text;
    return text.substring(0, maxLength) + '...';
  }

  private _getFriendlyName(entityId: string): string {
    if (!entityId || !this.hass || !this.hass.states[entityId]) return '';
    return this.hass.states[entityId]?.attributes?.friendly_name || entityId.split('.').pop() || '';
  }

  private _renderBar(bar: BarConfig, index: number) {
    const isExpanded = this._expandedBar === index;
    const isDragging = this._draggedBarIndex === index;
    const isDropTarget = this._dropTargetIndex === index;

    // Get entity display name for the header
    const entityName = this._getFriendlyName(bar.entity);
    const displayName = this._truncateText(entityName, 20);

    // Create alignment options for the selector
    const alignmentOptions = [
      { value: 'flex-start', label: 'Left' },
      { value: 'center', label: 'Center' },
      { value: 'flex-end', label: 'Right' },
    ];

    return html`
      <div
        class="bar ${isExpanded ? 'expanded' : ''} ${isDragging ? 'dragging' : ''} ${isDropTarget
          ? 'drop-target'
          : ''}"
        draggable="true"
        @dragstart=${e => this._handleDragStart(e, index)}
        @dragend=${this._handleDragEnd}
        @dragover=${e => this._handleDragOver(e, index)}
        @dragleave=${this._handleDragLeave}
        @drop=${e => this._handleDrop(e, index)}
      >
        <div class="bar-header" @click=${() => this._toggleBarExpand(index)}>
          <div class="bar-title">
            <div class="drag-handle" @mousedown=${_ => (this._preventExpandCollapse = true)}>
              <ha-icon icon="mdi:drag"></ha-icon>
            </div>
            Bar ${index + 1}
            <span class="bar-entity">${displayName || 'No entity selected'}</span>
          </div>
          <div class="bar-actions">
            <ha-icon-button
              .path=${isExpanded ? ICON_PATH_COLLAPSE : ICON_PATH_EXPAND}
              @click=${e => {
                e.stopPropagation();
                this._toggleBarExpand(index);
              }}
            >
            </ha-icon-button>
            <ha-icon-button
              .path=${ICON_PATH_DELETE}
              @click=${e => {
                e.stopPropagation();
                this._removeBar(index);
              }}
            >
            </ha-icon-button>
          </div>
        </div>

        ${isExpanded
          ? html`
              <div class="bar-content">
                <!-- Main bar properties -->
                <div class="section-group">
                  <div class="subsection-header">
                    <span>Bar Configuration</span>
                  </div>

                  <ha-form
                    .hass=${this.hass}
                    .data=${this._prepareBarData(bar, index)}
                    .schema=${this._getMainBarSchema(index)}
                    .computeLabel=${schema => schema.label || schema.name}
                    .computeDescription=${schema => schema.description}
                    @value-changed=${ev => this._barValueChanged(ev, index)}
                  ></ha-form>
                </div>

                <!-- Left side properties -->
                <div class="section-group">
                  <div class="subsection-header">
                    <span>Left Side</span>
                    <ha-switch
                      .checked=${bar.show_left !== false}
                      @change=${e => this._updateBarProperty(index, 'show_left', e.target.checked)}
                      title="Show or hide the left side label of the bar"
                    ></ha-switch>
                  </div>

                  ${bar.show_left !== false
                    ? html`
                        <ha-form
                          .hass=${this.hass}
                          .data=${this._prepareBarData(bar, index)}
                          .schema=${this._getLeftSideSchema(index)}
                          .computeLabel=${schema => schema.label || schema.name}
                          .computeDescription=${schema => schema.description}
                          @value-changed=${ev => this._barValueChanged(ev, index)}
                        ></ha-form>

                        <!-- Replace ha-select with ha-form for alignment -->
                        ${bar.show_right === false
                          ? html`
                              <div class="alignment-control">
                                <ha-form
                                  .hass=${this.hass}
                                  .data=${{ alignment: bar.alignment || 'flex-start' }}
                                  .schema=${[
                                    {
                                      name: 'alignment',
                                      selector: {
                                        select: {
                                          options: alignmentOptions,
                                          mode: 'dropdown',
                                        },
                                      },
                                      label: 'Alignment',
                                      description:
                                        'Controls how this label is aligned under the bar.',
                                    },
                                  ]}
                                  @value-changed=${ev => {
                                    ev.stopPropagation();
                                    this._updateBarProperty(
                                      index,
                                      'alignment',
                                      ev.detail.value.alignment
                                    );
                                  }}
                                ></ha-form>
                                <div class="helper-text">
                                  Controls how this label is aligned under the bar.
                                </div>
                              </div>
                            `
                          : ''}
                      `
                    : html` <div class="side-disabled">Left side is hidden</div> `}
                </div>

                <!-- Right side properties -->
                <div class="section-group">
                  <div class="subsection-header">
                    <span>Right Side</span>
                    <ha-switch
                      .checked=${bar.show_right !== false}
                      @change=${e => this._updateBarProperty(index, 'show_right', e.target.checked)}
                      title="Show or hide the right side label of the bar"
                    ></ha-switch>
                  </div>

                  ${bar.show_right !== false
                    ? html`
                        <ha-form
                          .hass=${this.hass}
                          .data=${this._prepareBarData(bar, index)}
                          .schema=${this._getRightSideSchema(index)}
                          .computeLabel=${schema => schema.label || schema.name}
                          .computeDescription=${schema => schema.description}
                          @value-changed=${ev => this._barValueChanged(ev, index)}
                        ></ha-form>

                        <!-- Replace ha-select with ha-form for alignment -->
                        ${bar.show_left === false
                          ? html`
                              <div class="alignment-control">
                                <ha-form
                                  .hass=${this.hass}
                                  .data=${{ alignment: bar.alignment || 'flex-start' }}
                                  .schema=${[
                                    {
                                      name: 'alignment',
                                      selector: {
                                        select: {
                                          options: alignmentOptions,
                                          mode: 'dropdown',
                                        },
                                      },
                                      label: 'Alignment',
                                      description:
                                        'Controls how this label is aligned under the bar.',
                                    },
                                  ]}
                                  @value-changed=${ev => {
                                    ev.stopPropagation();
                                    this._updateBarProperty(
                                      index,
                                      'alignment',
                                      ev.detail.value.alignment
                                    );
                                  }}
                                ></ha-form>
                                <div class="helper-text">
                                  Controls how this label is aligned under the bar.
                                </div>
                              </div>
                            `
                          : ''}
                      `
                    : html` <div class="side-disabled">Right side is hidden</div> `}
                </div>

                <!-- Colors configuration -->
                ${this._renderColorPickersGrid(bar, index)}

                <!-- Gradient toggle -->
                <div class="section-group" @click=${e => e.stopPropagation()}>
                  <div class="subsection-header">
                    <span>Gradient Mode</span>
                  </div>
                  <div style="padding: 16px;">
                    <ha-form
                      .hass=${this.hass}
                      .data=${this._prepareBarData(bar, index)}
                      .schema=${this._getGradientToggleSchema(index)}
                      .computeLabel=${schema => schema.label || schema.name}
                      .computeDescription=${schema => schema.description}
                      @value-changed=${ev => {
                        ev.stopPropagation();
                        this._barValueChanged(ev, index);
                      }}
                    ></ha-form>
                  </div>
                </div>

                <!-- Animation configuration -->
                <div class="section-group" @click=${e => e.stopPropagation()}>
                  <div class="subsection-header">
                    <span>Bar Animation</span>
                  </div>
                  <div style="padding: 16px;">
                    <ha-form
                      .hass=${this.hass}
                      .data=${this._prepareBarData(bar, index)}
                      .schema=${this._getAnimationSchema(index)}
                      .computeLabel=${schema => schema.label || schema.name}
                      .computeDescription=${schema => schema.description}
                      @value-changed=${ev => {
                        ev.stopPropagation();
                        this._barValueChanged(ev, index);
                      }}
                    ></ha-form>
                  </div>
                </div>

                ${this._renderGradientEditor(bar, index)}
              </div>
            `
          : ''}
      </div>
    `;
  }

  // Split the schema into different parts for better organization
  private _getMainBarSchema(index: number) {
    return [
      {
        name: `bars.${index}.entity`,
        selector: { entity: {} },
        label: 'Bar Percentage Entity',
        description:
          'Select an entity that returns a percentage value (0-100). This controls the fill level of the bar.',
      },
      {
        name: `bars.${index}.limit_entity`,
        selector: { entity: {} },
        label: 'Limit Entity (optional)',
        description:
          'Optional: Add a vertical indicator line on the bar (e.g., charge limit for EV battery).',
      },
      {
        name: `bars.${index}.limit_indicator_color`,
        selector: { color: { type: 'hex' } },
        label: 'Limit Indicator Color',
        description: 'Color of the vertical line that indicates the limit position on the bar.',
      },
      {
        name: `bars.${index}.bar_size`,
        selector: {
          select: {
            options: BAR_SIZE_OPTIONS,
            mode: 'dropdown',
          },
        },
        label: 'Bar Size',
        description: 'Set the thickness/height of the progress bar.',
      },
      {
        name: `bars.${index}.width`,
        selector: {
          select: {
            options: BAR_WIDTH_OPTIONS,
            mode: 'dropdown',
          },
        },
        label: 'Bar Width',
        description: 'Set the width of the bar as a percentage of the card width.',
      },
      {
        name: `bars.${index}.alignment`,
        selector: {
          select: {
            options: [
              { value: 'space-between', label: 'Space Between' },
              { value: 'flex-start', label: 'Left' },
              { value: 'center', label: 'Center' },
              { value: 'flex-end', label: 'Right' },
            ],
            mode: 'dropdown',
          },
        },
        label: 'Label Alignment',
        description: 'Alignment of labels below the bar.',
      },
      {
        type: 'section',
        label: 'Animation',
      },
      {
        name: `bars.${index}.animation_entity`,
        selector: { entity: {} },
        label: 'Action Entity',
        description: 'Entity whose state will trigger an animation on the bar.',
      },
      {
        name: `bars.${index}.animation_state`,
        selector: { text: {} },
        label: 'Entity State',
        description: 'When the entity matches this state, the animation will be triggered.',
      },
      {
        name: `bars.${index}.animation_type`,
        selector: {
          select: {
            options: BAR_ANIMATION_OPTIONS,
            mode: 'dropdown',
          },
        },
        label: 'Animation Type',
        description: 'Choose the animation to display when the entity state matches.',
      },
    ];
  }

  private _getLeftSideSchema(index: number) {
    return [
      {
        name: `bars.${index}.left_title`,
        selector: { text: {} },
        label: 'Left Title',
        description: 'Optional label to display on the left side below the bar.',
      },
      {
        name: `bars.${index}.left_entity`,
        selector: { entity: {} },
        label: 'Left Entity',
        description: 'Entity whose value will be displayed on the left side of the bar.',
      },
    ];
  }

  private _getRightSideSchema(index: number) {
    return [
      {
        name: `bars.${index}.right_title`,
        selector: { text: {} },
        label: 'Right Title',
        description: 'Optional label to display on the right side below the bar.',
      },
      {
        name: `bars.${index}.right_entity`,
        selector: { entity: {} },
        label: 'Right Entity',
        description: 'Entity whose value will be displayed on the right side of the bar.',
      },
    ];
  }

  private _prepareBarData(bar: BarConfig, index: number) {
    // Create flattened data for the form with prefixed keys
    const data = {};

    // If titles aren't set but entities are, use friendly names as defaults
    const leftTitle =
      bar.left_title || (bar.left_entity ? this._getFriendlyName(bar.left_entity) : '');
    const rightTitle =
      bar.right_title || (bar.right_entity ? this._getFriendlyName(bar.right_entity) : '');

    // Truncate the titles to ensure they don't break layout
    const preparedBar = {
      ...bar,
      left_title: leftTitle ? this._truncateText(leftTitle) : '',
      right_title: rightTitle ? this._truncateText(rightTitle) : '',
    };

    // Flatten the data for the form
    Object.entries(preparedBar).forEach(([key, value]) => {
      data[`bars.${index}.${key}`] = value;
    });

    return data;
  }

  private _renderColorPickersGrid(bar: BarConfig, index: number) {
    // Define the color fields to display
    const colorFields = [
      { name: 'bar_color', label: 'Bar Color', default: DEFAULT_COLORS.bar_color },
      {
        name: 'background_color',
        label: 'Background Color',
        default: DEFAULT_COLORS.background_color,
      },
      { name: 'border_color', label: 'Border Color', default: DEFAULT_COLORS.border_color },
      {
        name: 'limit_indicator_color',
        label: 'Limit Indicator Color',
        default: DEFAULT_COLORS.limit_indicator_color,
      },
      {
        name: 'left_title_color',
        label: 'Left Title Color',
        default: DEFAULT_COLORS.left_title_color,
      },
      {
        name: 'left_text_color',
        label: 'Left Value Color',
        default: DEFAULT_COLORS.left_text_color,
      },
      {
        name: 'right_title_color',
        label: 'Right Title Color',
        default: DEFAULT_COLORS.right_title_color,
      },
      {
        name: 'right_text_color',
        label: 'Right Value Color',
        default: DEFAULT_COLORS.right_text_color,
      },
    ];

    return html`
      <div class="section-header">Colors</div>
      <div class="color-pickers-grid">
        ${colorFields.map(field => {
          // Get the current value or use default
          const currentValue = bar[field.name] || field.default;

          return html`
            <div class="color-picker-item">
              <ultra-vehicle-color-picker
                .label=${field.label}
                .value=${currentValue}
                @value-changed=${(ev: CustomEvent) => {
                  ev.stopPropagation();
                  this._updateBarProperty(index, field.name, ev.detail.value);
                }}
              ></ultra-vehicle-color-picker>
              <ha-icon-button
                class="color-reset-button"
                .path=${'M19,8L15,12H18A6,6 0 0,1 12,18C11,18 10.03,17.75 9.2,17.3L7.74,18.76C8.97,19.54 10.43,20 12,20A8,8 0 0,0 20,12H23L19,8M6,12A6,6 0 0,1 12,6C13,6 13.97,6.25 14.8,6.7L16.26,5.24C15.03,4.46 13.57,4 12,4A8,8 0 0,0 4,12H1L5,16L9,12H6Z'}
                @click=${() => this._resetBarColor(index, field.name, field.default)}
                title="Reset to default color"
              ></ha-icon-button>
            </div>
          `;
        })}
      </div>
    `;
  }

  // Updated method to convert CSS variables to actual colors for display
  private _convertCssVariableToColor(colorValue: string): string {
    if (!colorValue) {
      return '#000000';
    }

    // Handle CSS variables by mapping them to appropriate colors
    if (typeof colorValue === 'string' && colorValue.includes('var(--')) {
      // For standard CSS variables, map to appropriate colors
      if (colorValue.includes('--text-primary-color')) {
        if (colorValue.includes('#777777')) {
          return '#777777'; // Use the fallback for title colors
        }
        if (colorValue.includes('#000000')) {
          return '#000000'; // Use the fallback for text colors
        }
        return '#FFFFFF'; // Default fallback
      } else if (colorValue.includes('--primary-color')) {
        return '#03A9F4';
      }

      // Extract fallback if present
      const fallbackMatch = colorValue.match(/var\(--[\w-]+,\s*([^)]+)\)/);
      if (fallbackMatch && fallbackMatch[1]) {
        return fallbackMatch[1].trim();
      }

      // Default fallback
      return '#FFFFFF';
    }

    return colorValue;
  }

  // Updated reset method to ensure the color picker updates properly
  private _resetBarColor(index: number, colorProperty: string, defaultValue: string) {
    const bars = [...(this.config.bars || [])];
    if (bars[index]) {
      // Update with the default color
      bars[index] = {
        ...bars[index],
        [colorProperty]: defaultValue,
      };

      // Remove the property completely if it's set to default to ensure clean config
      if (defaultValue === DEFAULT_COLORS[colorProperty]) {
        delete bars[index][colorProperty];
      }

      // Update the config
      this._updateConfig({ bars });

      // Force a re-render to ensure UI updates
      setTimeout(() => {
        this.requestUpdate();
      }, 10);
    }
  }

  private _updateBarProperty(index: number, property: string, value: any) {
    const bars = [...(this.config.bars || [])];
    if (bars[index]) {
      bars[index] = {
        ...bars[index],
        [property]: value,
      };
      this._updateConfig({ bars });
    }
  }

  private _renderActionSchema(actionEntity: string) {
    if (!actionEntity || !this.hass.states[actionEntity]) {
      return html``;
    }

    // Get all available states from the selected entity
    const actionEntityObj = this.hass.states[actionEntity];
    const currentState = actionEntityObj.state;
    const friendlyName = actionEntityObj.attributes.friendly_name || actionEntity.split('.').pop();

    // Create state options from the entity
    const stateOptions = this._getEntityStateOptions(actionEntity);

    // Show the current entity state in the UI
    const entityStateDisplay = html`
      <div class="current-entity-state">
        <div class="entity-state-header">
          <span>Current state of <strong>${friendlyName}</strong>:</span>
          <span class="entity-state-value">${currentState}</span>
        </div>
      </div>
    `;

    // First part: Action State
    const actionStateSchema = html`
      ${entityStateDisplay}
      <ha-form
        class="config-form action-state-form"
        .hass=${this.hass}
        .data=${this.config}
        .schema=${[
          {
            name: 'action_state',
            selector: {
              select: {
                options: stateOptions,
                mode: 'dropdown',
              },
            },
            label: 'Action State',
            description: 'Select the state that will trigger the action image.',
          },
        ]}
        .computeLabel=${schema => schema.label || schema.name}
        @value-changed=${this._valueChanged}
      ></ha-form>
    `;

    // Second part (conditional): Action Image Type and Upload Action Image
    let actionImageContent = html``;
    if (this.config.action_state) {
      actionImageContent = html`
        <!-- Action Image Type dropdown -->
        <ha-form
          class="config-form action-image-type-form"
          .hass=${this.hass}
          .data=${this.config}
          .schema=${[
            {
              name: 'action_image_type',
              selector: {
                select: {
                  options: IMAGE_TYPE_OPTIONS,
                  mode: 'dropdown',
                },
              },
              label: 'Action Image Type',
              description:
                'Select how to display the action image for "${this.config.action_state}" state.',
            },
          ]}
          .computeLabel=${schema => schema.label || schema.name}
          .computeDescription=${schema => schema.description}
          @value-changed=${this._valueChanged}
        ></ha-form>

        <!-- File upload for Action Image if upload type is selected - directly after dropdown -->
        ${this.config.action_image_type === 'upload'
          ? html`
              <div class="upload-container">
                <label>Upload Action Image for "${this.config.action_state}" state</label>
                <input
                  type="file"
                  accept="image/*"
                  @change=${e => this._handleActionImageUpload(e)}
                  style="width: 100%; margin-top: 8px; margin-bottom: 16px;"
                />
              </div>
            `
          : ''}

        <!-- URL field if URL type is selected -->
        ${this.config.action_image_type === 'url'
          ? html`
              <ha-form
                class="config-form action-image-url-form"
                .hass=${this.hass}
                .data=${this.config}
                .schema=${[
                  {
                    name: 'action_image',
                    selector: { text: {} },
                    label: 'Action Image URL',
                    description:
                      'Enter the full URL to an image for the "${this.config.action_state}" state.',
                  },
                ]}
                .computeLabel=${schema => schema.label || schema.name}
                .computeDescription=${schema => schema.description}
                @value-changed=${this._valueChanged}
              ></ha-form>
            `
          : ''}

        <!-- Entity picker if entity type is selected -->
        ${this.config.action_image_type === 'entity'
          ? html`
              <ha-form
                class="config-form action-image-entity-form"
                .hass=${this.hass}
                .data=${this.config}
                .schema=${[
                  {
                    name: 'action_image_entity',
                    selector: { entity: {} },
                    label: 'Action Image Entity',
                    description:
                      'Select an entity that returns an image URL for the "${this.config.action_state}" state.',
                  },
                ]}
                .computeLabel=${schema => schema.label || schema.name}
                .computeDescription=${schema => schema.description}
                @value-changed=${this._valueChanged}
              ></ha-form>
            `
          : ''}

        <!-- Add image width slider if action image type is not "none" - separate from upload -->
        ${this.config.action_image_type && this.config.action_image_type !== 'none'
          ? html`
              <ha-form
                class="config-form action-image-width-form"
                .hass=${this.hass}
                .data=${this.config}
                .schema=${[
                  {
                    name: 'action_image_width',
                    selector: {
                      number: {
                        min: 0,
                        max: 100,
                        step: 1,
                        unit: '%',
                        mode: 'slider',
                      },
                    },
                    label: 'Image Width',
                    description:
                      'Adjust the width of the action image (height will adjust automatically)',
                  },
                ]}
                .computeLabel=${schema => schema.label || schema.name}
                .computeDescription=${schema => schema.description}
                @value-changed=${this._valueChanged}
              ></ha-form>
            `
          : ''}

        <!-- Image crop controls as a separate element at the bottom -->
        ${this.config.action_image_type === 'upload'
          ? html`
              <div class="crop-accordion">
                <div
                  class="crop-accordion-header"
                  @click=${() => {
                    this._actionCropExpanded = !this._actionCropExpanded;
                    this.requestUpdate();
                  }}
                >
                  <span>Image Crop</span>
                  <ha-icon
                    icon="${this._actionCropExpanded ? 'mdi:chevron-up' : 'mdi:chevron-down'}"
                  ></ha-icon>
                </div>

                ${this._actionCropExpanded
                  ? html`
                      <div class="crop-controls">
                        ${this._renderCropSliders('action_image_crop')}
                      </div>
                    `
                  : ''}
              </div>
            `
          : ''}
      `;
    }

    return html` <div class="action-content">${actionStateSchema} ${actionImageContent}</div> `;
  }

  private _getEntityStateOptions(entityId: string) {
    if (!entityId || !this.hass || !this.hass.states[entityId]) {
      return [];
    }

    const entity = this.hass.states[entityId];
    let states: string[] = [];

    // For domain-specific entities, get their specific states
    if (entityId.startsWith('lock.')) {
      states = ['locked', 'unlocked', 'jammed', 'locking', 'unlocking'];
    } else if (entityId.startsWith('binary_sensor.')) {
      states = ['on', 'off'];
    } else if (entityId.startsWith('device_tracker.')) {
      states = ['home', 'not_home', 'away'];
    } else if (entityId.startsWith('sensor.')) {
      // For BMW and similar, try to get common states
      if (entityId.includes('charging')) {
        states = [
          'charging',
          'not_charging',
          'complete',
          'Charging',
          'Not Charging',
          'Charge Complete',
        ];
      } else if (entityId.includes('door')) {
        states = ['open', 'closed', 'Open', 'Closed', 'locked', 'unlocked'];
      } else if (entityId.includes('engine') || entityId.includes('ignition')) {
        states = ['on', 'off', 'running', 'stopped', 'On', 'Off', 'Running', 'Stopped'];
      } else {
        // Include current state as default option
        states = entity.state ? [entity.state] : [];

        // Try to add more common states for car-related entities
        if (
          entityId.toLowerCase().includes('car') ||
          entityId.toLowerCase().includes('vehicle') ||
          entityId.toLowerCase().includes('bmw') ||
          entityId.toLowerCase().includes('tesla')
        ) {
          states = [...new Set([...states, 'on', 'off', 'charging', 'driving', 'parked', 'home'])];
        }
      }
    } else {
      // Generic fallback using current state and common states
      states = entity.state ? [entity.state] : [];

      // Add some common states for any entity
      if (entityId.includes('status')) {
        states = [...new Set([...states, 'on', 'off', 'idle', 'busy', 'error', 'ready'])];
      }
    }

    // Make sure we have at least the current state
    if (entity.state && !states.includes(entity.state)) {
      states.unshift(entity.state);
    }

    // Make state options unique
    const uniqueStates = [...new Set(states)];

    return uniqueStates.map(state => ({
      value: state,
      label: state.replace(/_/g, ' ').replace(/\b\w/g, l => l.toUpperCase()),
    }));
  }

  private async _handleActionImageUpload(e: Event) {
    const input = e.target as HTMLInputElement;
    if (!input.files || !input.files[0]) {
      console.log('[ACTION UPLOAD DEBUG] No file selected');
      return;
    }

    const file = input.files[0];

    // Get action entity and state from config
    const actionEntity = this.config.action_entity || '';
    const actionState = this.config.action_state || '';

    if (!actionEntity || !actionState) {
      console.log('[ACTION UPLOAD DEBUG] Missing action entity or state');
      alert('Please select an action entity and state first');
      return;
    }

    console.log(
      `[ACTION UPLOAD DEBUG] Processing file ${file.name} for ${actionEntity}/${actionState}`
    );
    console.log('[ACTION UPLOAD DEBUG] File details:', file.type, file.size);

    try {
      console.log('[ACTION UPLOAD DEBUG] Starting upload to Home Assistant API');

      // Create form data for the API request
      const formData = new FormData();
      formData.append('file', file);

      // Get the Home Assistant auth token
      const token = this.hass.auth.data.access_token;

      console.log('[ACTION UPLOAD DEBUG] Sending request to /api/image_upload endpoint');

      // Upload the file to Home Assistant's image_upload API
      const response = await fetch('/api/image_upload', {
        method: 'POST',
        headers: {
          Authorization: `Bearer ${token}`,
        },
        body: formData,
      });

      if (!response.ok) {
        throw new Error(`Failed to upload image: ${response.statusText}`);
      }

      const data = await response.json();
      console.log('[ACTION UPLOAD DEBUG] Image upload response:', data);

      if (!data || !data.path) {
        throw new Error('Invalid response from server: missing path');
      }

      // The path returned is what we want to store
      const imagePath = data.path;
      console.log('[ACTION UPLOAD DEBUG] Image path from server:', imagePath);

      // Create a deep copy of the config
      const newConfig = JSON.parse(JSON.stringify(this.config));
      console.log(
        '[ACTION UPLOAD DEBUG] Config before update:',
        JSON.stringify(newConfig.action_images || {})
      );

      // Initialize action_images if needed
      if (!newConfig.action_images) {
        newConfig.action_images = {};
      }

      // Initialize entity entry if needed
      if (!newConfig.action_images[actionEntity]) {
        newConfig.action_images[actionEntity] = {};
      }

      // Store the image path from the API, not base64 data
      newConfig.action_images[actionEntity][actionState] = imagePath;
      console.log(
        '[ACTION UPLOAD DEBUG] New action_images config:',
        JSON.stringify(newConfig.action_images)
      );

      // Update the config
      this._updateConfig(newConfig);
      console.log('[ACTION UPLOAD DEBUG] Config updated successfully');
    } catch (error) {
      console.error('[ACTION UPLOAD DEBUG] Error during upload process:', error);
      alert(
        'Failed to upload image. Please try again or upload the image manually to the Media Library.'
      );
    }
  }

  private _renderIconsTab() {
    const iconRows = this.config.icon_rows || [];

    return html`
      <div class="tab-content">
        <div class="settings-section">
          <div class="section-header">Icon Rows</div>
          <div class="settings-content">
            <div class="instructions">
              Create rows of icons to display in your vehicle card. Add multiple icons to each row
              and configure their appearance and behavior.
            </div>

            <div class="bar-list">
              ${iconRows.map((row, index) => this._renderIconRow(row, index))}
            </div>

            <div class="add-bar-container">
              <ha-button class="add-bar-button" @click=${this._addIconRow}>
                <ha-icon icon="mdi:plus" class="add-icon"></ha-icon>
                Add Icon Row
              </ha-button>
            </div>
          </div>
        </div>
      </div>
    `;
  }

  private _renderIconRow(row: IconRowConfig, rowIndex: number) {
    const isExpanded = this._expandedIconRow === row.id;
    const isDragging = this._draggedIconRow === row.id;
    const isDropTarget = this._dropTargetRow === row.id;

    return html`
      <div
        class="bar ${isExpanded ? 'expanded' : ''} ${isDragging ? 'dragging' : ''} ${isDropTarget
          ? 'drop-target'
          : ''}"
        draggable="true"
        @dragstart=${e => this._handleIconRowDragStart(e, row.id)}
        @dragend=${this._handleIconRowDragEnd}
        @dragover=${e => this._handleIconRowDragOver(e, row.id)}
        @dragleave=${this._handleIconRowDragLeave}
        @drop=${e => this._handleIconRowDrop(e, row.id)}
      >
        <div class="bar-header" @click=${() => this._toggleIconRowExpand(row.id)}>
          <div class="bar-grip">
            <ha-icon icon="mdi:drag"></ha-icon>
          </div>
          <div class="bar-title">
            Row ${rowIndex + 1}
            <span class="bar-details">${row.width}% width</span>
          </div>
          <div class="bar-actions">
            ${isExpanded
              ? html`
                  <ha-icon-button
                    @click=${e => {
                      e.stopPropagation();
                      this._removeIconRow(row.id);
                    }}
                  >
                    <ha-icon icon="mdi:delete"></ha-icon>
                  </ha-icon-button>
                `
              : ''}
            <ha-icon-button
              @click=${e => {
                e.stopPropagation();
                this._toggleIconRowExpand(row.id);
              }}
            >
              <ha-icon icon="${isExpanded ? 'mdi:chevron-up' : 'mdi:chevron-down'}"></ha-icon>
            </ha-icon-button>
          </div>
        </div>

        ${isExpanded
          ? html`
              <div class="bar-content">
                <!-- Row configuration -->
                <div class="settings-section">
                  <div class="section-header">Row Settings</div>
                  <div class="settings-content">
                    <ha-form
                      .hass=${this.hass}
                      .data=${{
                        width: row.width,
                        alignment: row.alignment,
                        spacing: row.spacing || 'medium',
                      }}
                      .schema=${[
                        {
                          name: 'width',
                          selector: {
                            select: {
                              options: [
                                { value: '100', label: '100% (Full Width)' },
                                { value: '75', label: '75% Width' },
                                { value: '50', label: '50% Width' },
                                { value: '25', label: '25% Width' },
                              ],
                              mode: 'dropdown',
                            },
                          },
                          label: 'Row Width',
                          description:
                            'Set the width of the icon row as a percentage of the card width',
                        } as any,
                        {
                          name: 'alignment',
                          selector: {
                            select: {
                              options: [
                                { value: 'flex-start', label: 'Left' },
                                { value: 'center', label: 'Center' },
                                { value: 'flex-end', label: 'Right' },
                                { value: 'space-between', label: 'Space Between' },
                                { value: 'space-around', label: 'Space Around' },
                                { value: 'space-evenly', label: 'Space Evenly' },
                              ],
                              mode: 'dropdown',
                            },
                          },
                          label: 'Icon Alignment',
                          description: 'How icons are positioned within the row',
                        } as any,
                        {
                          name: 'spacing',
                          selector: {
                            select: {
                              options: [
                                { value: 'none', label: 'None' },
                                { value: 'small', label: 'Small' },
                                { value: 'medium', label: 'Medium' },
                                { value: 'large', label: 'Large' },
                              ],
                              mode: 'dropdown',
                            },
                          },
                          label: 'Icon Spacing',
                          description: 'Amount of space between icons',
                        } as any,
                      ]}
                      .computeLabel=${schema => schema.label || this._formatFieldName(schema.name)}
                      .computeDescription=${schema => schema.description}
                      @value-changed=${e => this._updateIconRowConfig(row.id, e.detail.value)}
                    ></ha-form>
                  </div>
                </div>

                <!-- Icons List -->
                <div class="settings-section">
                  <div class="section-header">Icons</div>
                  <div class="settings-content">
                    <div class="bar-list mini-bar-list">
                      ${row.icons.map((icon, iconIndex) =>
                        this._renderIcon(row.id, icon, iconIndex)
                      )}
                    </div>

                    <div class="add-bar-container">
                      <ha-button class="add-icon-button" @click=${() => this._addIcon(row.id)}>
                        <ha-icon icon="mdi:plus" class="add-icon"></ha-icon>
                        Add Icon
                      </ha-button>
                    </div>
                  </div>
                </div>
              </div>
            `
          : ''}
      </div>
    `;
  }

  private _renderIcon(rowId: string, icon: IconConfig, iconIndex: number) {
    const isExpanded =
      this._expandedIcon &&
      this._expandedIcon.rowId === rowId &&
      this._expandedIcon.iconIndex === iconIndex;

    const isDragging =
      this._draggedIcon &&
      this._draggedIcon.rowId === rowId &&
      this._draggedIcon.iconIndex === iconIndex;

    const isDropTarget =
      this._dropTargetIcon &&
      this._dropTargetIcon.rowId === rowId &&
      this._dropTargetIcon.iconIndex === iconIndex;

    // Get friendly name from entity or use custom name if provided
    const entityName = icon.entity ? this._getFriendlyName(icon.entity) : '';
    const displayName = icon.name || entityName || 'Icon ' + (iconIndex + 1);
    const truncatedName = this._truncateText(displayName, 15);

    // Preview values
    const displayIcon = icon.icon_inactive || 'mdi:help-circle-outline';
    const displayActiveIcon = icon.icon_active || 'mdi:help-circle';
    const displayColor = icon.color_inactive || 'var(--secondary-text-color)';
    const displayActiveColor = icon.color_active || 'var(--primary-color)';

    return html`
      <div
        class="mini-bar ${isExpanded ? 'expanded' : ''} ${isDragging
          ? 'dragging'
          : ''} ${isDropTarget ? 'drop-target' : ''}"
        draggable="true"
        @dragstart=${e => this._handleIconDragStart(e, rowId, iconIndex)}
        @dragend=${this._handleIconDragEnd}
        @dragover=${e => this._handleIconDragOver(e, rowId, iconIndex)}
        @dragleave=${this._handleIconDragLeave}
        @drop=${e => this._handleIconDrop(e, rowId, iconIndex)}
      >
        <div class="mini-bar-header" @click=${() => this._toggleIconEdit(rowId, iconIndex)}>
          <div class="bar-grip">
            <ha-icon icon="mdi:drag"></ha-icon>
          </div>
          <div class="bar-icon-preview">
            <ha-icon icon="${displayIcon}" style="color: ${displayColor};"></ha-icon>
          </div>
          <div class="bar-title">${truncatedName || 'Unnamed Icon'}</div>
          <div class="bar-actions">
            <ha-icon-button
              @click=${e => {
                e.stopPropagation();
                e.preventDefault();
                this._removeIcon(rowId, iconIndex);
              }}
              @mousedown=${e => {
                e.stopPropagation();
                e.preventDefault();
              }}
            >
              <ha-icon icon="mdi:delete"></ha-icon>
            </ha-icon-button>
            <ha-icon-button
              @click=${e => {
                e.stopPropagation();
                this._toggleIconEdit(rowId, iconIndex);
              }}
            >
              <ha-icon icon="${isExpanded ? 'mdi:chevron-up' : 'mdi:chevron-down'}"></ha-icon>
            </ha-icon-button>
          </div>
        </div>

        ${isExpanded
          ? html`
              <div class="mini-bar-content">
                <!-- Common Settings - Removed header -->
                <div class="section-group">
                  <ha-form
                    .hass=${this.hass}
                    .data=${icon}
                    .schema=${[
                      {
                        name: 'on_click_action',
                        selector: {
                          select: {
                            options: ICON_ACTION_OPTIONS,
                            mode: 'dropdown',
                          },
                        },
                        label: 'Click Action',
                      },
                      {
                        name: 'entity',
                        selector: { entity: {} },
                        label: 'Entity',
                        description: 'Entity that determines the icon state',
                      },
                      {
                        name: 'name',
                        selector: { text: {} },
                        label: 'Name',
                        description: 'Custom name (uses entity name if empty)',
                      },
                      {
                        name: 'show_name',
                        selector: { boolean: {} },
                        label: 'Show Name',
                        description: 'Display the name below the icon',
                      },
                      {
                        name: 'show_state',
                        selector: { boolean: {} },
                        label: 'Show State',
                        description: 'Display the entity state below the icon',
                      },
                      {
                        name: 'show_units',
                        selector: { boolean: {} },
                        label: 'Show Units',
                        description: 'Display unit of measurement with the state value',
                      },
                    ]}
                    .computeLabel=${schema => schema.label || this._formatFieldName(schema.name)}
                    .computeDescription=${schema => schema.description}
                    @value-changed=${e => this._updateIconConfig(rowId, iconIndex, e.detail.value)}
                  ></ha-form>
                </div>

                <!-- Add new appearance settings section -->
                <div class="section-group">
                  <div class="subsection-header">
                    <span>Appearance Settings</span>
                  </div>
                  <ha-form
                    .hass=${this.hass}
                    .data=${icon}
                    .schema=${[
                      {
                        name: 'text_position',
                        selector: {
                          select: {
                            options: ICON_TEXT_POSITION_OPTIONS,
                            mode: 'dropdown',
                          },
                        },
                        label: 'Text Position',
                        description: 'Position of the text relative to the icon',
                      },
                      {
                        name: 'vertical_alignment',
                        selector: {
                          select: {
                            options: ICON_VERTICAL_ALIGNMENT_OPTIONS,
                            mode: 'dropdown',
                          },
                        },
                        label: 'Vertical Alignment',
                        description: 'How the icon is aligned vertically in the row',
                      },
                      {
                        name: 'icon_size',
                        selector: {
                          select: {
                            options: ICON_SIZE_OPTIONS,
                            mode: 'dropdown',
                          },
                        },
                        label: 'Icon Size',
                        description: 'Size of the icon',
                      },
                      {
                        name: 'text_size',
                        selector: {
                          select: {
                            options: TEXT_SIZE_OPTIONS,
                            mode: 'dropdown',
                          },
                        },
                        label: 'Text Size',
                        description: 'Size of the text below/next to the icon',
                      },
                    ]}
                    .computeLabel=${schema => schema.label || this._formatFieldName(schema.name)}
                    .computeDescription=${schema => schema.description}
                    @value-changed=${e => this._updateIconConfig(rowId, iconIndex, e.detail.value)}
                  ></ha-form>
                </div>

                <!-- Active State Section -->
                <div class="icon-state-section active-section">
                  <div class="icon-state-header">
                    <div class="icon-state-title">Active State</div>
                    <div class="icon-state-preview">
                      <ha-icon
                        icon="${displayActiveIcon}"
                        style="color: ${displayActiveColor};"
                      ></ha-icon>
                      ${icon.show_name !== false
                        ? html`<div class="preview-name">${truncatedName}</div>`
                        : ''}
                      ${icon.show_state
                        ? html`<div class="preview-state-value">Active State</div>`
                        : ''}
                    </div>
                  </div>
                  <div class="icon-state-content">
                    <ha-form
                      .hass=${this.hass}
                      .data=${icon}
                      .schema=${[
                        {
                          name: 'active_state',
                          selector: { text: {} },
                          label: 'Active State',
                          description:
                            'When the entity state matches this value, the icon will appear in its active state. For most entities, the default is "on".',
                        },
                        {
                          name: 'icon_active',
                          selector: { icon: {} },
                          label: 'Active Icon',
                          description: 'Icon to display when the entity is in its active state.',
                        },
                      ]}
                      .computeLabel=${schema => schema.label || this._formatFieldName(schema.name)}
                      .computeDescription=${schema => schema.description}
                      @value-changed=${e =>
                        this._updateIconConfig(rowId, iconIndex, e.detail.value)}
                    ></ha-form>
                    <div class="color-picker-container">
                      <div class="color-picker-header">
                        <div class="color-picker-label">Active Color</div>
                        <ha-icon-button
                          @click=${() => this._resetIconColor(rowId, iconIndex, 'active')}
                        >
                          <ha-icon icon="mdi:refresh"></ha-icon>
                        </ha-icon-button>
                      </div>
                      <ultra-vehicle-color-picker
                        .value=${icon.color_active || 'var(--primary-color)'}
                        @value-changed=${e =>
                          this._updateIconConfig(rowId, iconIndex, {
                            color_active: e.detail.value,
                          })}
                      ></ultra-vehicle-color-picker>
                    </div>
                  </div>
                </div>

                <!-- Inactive State Section -->
                <div class="icon-state-section inactive-section">
                  <div class="icon-state-header">
                    <div class="icon-state-title">Inactive State</div>
                    <div class="icon-state-preview">
                      <ha-icon icon="${displayIcon}" style="color: ${displayColor};"></ha-icon>
                      ${icon.show_name !== false
                        ? html`<div class="preview-name">${truncatedName}</div>`
                        : ''}
                      ${icon.show_state
                        ? html`<div class="preview-state-value">Inactive State</div>`
                        : ''}
                    </div>
                  </div>
                  <div class="icon-state-content">
                    <ha-form
                      .hass=${this.hass}
                      .data=${icon}
                      .schema=${[
                        {
                          name: 'inactive_state',
                          selector: { text: {} },
                          label: 'Inactive State',
                          description:
                            'When the entity state matches this value, the icon will appear in its inactive state. For most entities, the default is "off".',
                        },
                        {
                          name: 'icon_inactive',
                          selector: { icon: {} },
                          label: 'Inactive Icon',
                          description: 'Icon to display when the entity is in its inactive state.',
                        },
                      ]}
                      .computeLabel=${schema => schema.label || this._formatFieldName(schema.name)}
                      .computeDescription=${schema => schema.description}
                      @value-changed=${e =>
                        this._updateIconConfig(rowId, iconIndex, e.detail.value)}
                    ></ha-form>
                    <div class="color-picker-container">
                      <div class="color-picker-header">
                        <div class="color-picker-label">Inactive Color</div>
                        <ha-icon-button
                          @click=${() => this._resetIconColor(rowId, iconIndex, 'inactive')}
                        >
                          <ha-icon icon="mdi:refresh"></ha-icon>
                        </ha-icon-button>
                      </div>
                      <ultra-vehicle-color-picker
                        .value=${icon.color_inactive || 'var(--secondary-text-color)'}
                        @value-changed=${e =>
                          this._updateIconConfig(rowId, iconIndex, {
                            color_inactive: e.detail.value,
                          })}
                      ></ultra-vehicle-color-picker>
                    </div>
                  </div>
                </div>
              </div>
            `
          : ''}
      </div>
    `;
  }

  // Helper methods for icon rows management
  private _addIconRow() {
    const iconRows = [...(this.config.icon_rows || [])];
    const newRow = this._createDefaultIconRow();
    iconRows.push(newRow);

    // Update the sections_order to include the new icon row
    const sectionsOrder = [...(this.config.sections_order || ['title', 'image', 'info'])];

    // Check if we're using the legacy section format (with 'icons') or individual icon rows
    const usesLegacyFormat = sectionsOrder.includes('icons');
    const hasIndividualIconRows = sectionsOrder.some(section => section.startsWith('icon_row_'));

    if (usesLegacyFormat) {
      // Already using legacy format, no need to modify sections_order
    } else if (hasIndividualIconRows) {
      // Using individual icon row sections, add a new one
      const newIconRowSectionId = `icon_row_${newRow.id}`;
      sectionsOrder.push(newIconRowSectionId);
    } else {
      // Using neither format, add the legacy 'icons' section for compatibility
      sectionsOrder.push('icons');
    }

    this._updateConfig({
      icon_rows: iconRows,
      sections_order: sectionsOrder,
    });

    this._expandedIconRow = newRow.id;
  }

  private _removeIconRow(rowId: string) {
    const iconRows = (this.config.icon_rows || []).filter(row => row.id !== rowId);

    // Update sections_order to remove the icon row section
    const sectionsOrder = [...(this.config.sections_order || [])];
    const iconRowSectionId = `icon_row_${rowId}`;
    const iconRowSectionIndex = sectionsOrder.indexOf(iconRowSectionId);

    if (iconRowSectionIndex !== -1) {
      sectionsOrder.splice(iconRowSectionIndex, 1);
    }

    this._updateConfig({
      icon_rows: iconRows,
      sections_order: sectionsOrder,
    });

    if (this._expandedIconRow === rowId) {
      this._expandedIconRow = null;
    }

    if (this._expandedIcon && this._expandedIcon.rowId === rowId) {
      this._expandedIcon = null;
    }
  }

  private _toggleIconRowExpand(rowId: string) {
    this._expandedIconRow = this._expandedIconRow === rowId ? null : rowId;

    // Close any open icon edit forms when collapsing a row
    if (
      this._expandedIcon &&
      this._expandedIcon.rowId === rowId &&
      this._expandedIconRow === null
    ) {
      this._expandedIcon = null;
    }
  }

  private _updateIconRowConfig(rowId: string, updates: Partial<IconRowConfig>) {
    const iconRows = [...(this.config.icon_rows || [])];
    const rowIndex = iconRows.findIndex(row => row.id === rowId);

    if (rowIndex >= 0) {
      // Log the update
      console.log(`[EDITOR] Updating icon row ${rowId}:`, updates);

      // Store the old values for comparison
      const oldAlignment = iconRows[rowIndex].alignment;

      // Create updated row
      iconRows[rowIndex] = {
        ...iconRows[rowIndex],
        ...updates,
      };

      // Log any alignment changes
      if (updates.alignment && updates.alignment !== oldAlignment) {
        console.log(
          `[EDITOR] Icon row alignment changed from ${oldAlignment} to ${updates.alignment}`
        );
      }

      this._updateConfig({ icon_rows: iconRows });

      // Force an immediate update
      setTimeout(() => this.requestUpdate(), 10);
    }
  }

  // Helper methods for icon management
  private _addIcon(rowId: string) {
    // Create a complete deep copy of the config to avoid reference issues
    const newConfig = JSON.parse(JSON.stringify(this.config));

    // Make sure icon_rows exists
    if (!newConfig.icon_rows) {
      newConfig.icon_rows = [];
    }

    // Find the row
    const rowIndex = newConfig.icon_rows.findIndex(row => row.id === rowId);

    if (rowIndex >= 0) {
      // Ensure the icons array exists
      if (!newConfig.icon_rows[rowIndex].icons) {
        newConfig.icon_rows[rowIndex].icons = [];
      }

      // Add a new default icon
      newConfig.icon_rows[rowIndex].icons.push({
        entity: '',
        icon_inactive: 'mdi:help-circle-outline',
        icon_active: 'mdi:help-circle',
        color_inactive: 'var(--secondary-text-color)',
        color_active: 'var(--primary-color)',
        inactive_state: 'off',
        show_state: false,
        show_name: true,
        name: '',
        on_click_action: 'toggle',
        text_position: 'bottom',
        vertical_alignment: 'center',
        icon_size: 'medium',
        text_size: 'medium',
      });

      // Get the index of the newly added icon
      const newIconIndex = newConfig.icon_rows[rowIndex].icons.length - 1;

      // Update the config
      this._updateConfig(newConfig);

      // Open the edit form for the new icon
      setTimeout(() => {
        this._expandedIcon = {
          rowId,
          iconIndex: newIconIndex,
        };
        this.requestUpdate();
      }, 50);
    }
  }

  private _removeIcon(rowId: string, iconIndex: number) {
    // Create a deep copy of the config to avoid reference issues
    const newConfig = JSON.parse(JSON.stringify(this.config));

    // Make sure icon_rows exists
    if (!newConfig.icon_rows || !Array.isArray(newConfig.icon_rows)) {
      console.warn('Cannot remove icon: icon_rows not found or not an array');
      return;
    }

    // Find the row
    const rowIndex = newConfig.icon_rows.findIndex(row => row.id === rowId);

    if (rowIndex === -1) {
      console.warn(`Cannot remove icon: row with id ${rowId} not found`);
      return;
    }

    const row = newConfig.icon_rows[rowIndex];

    // Make sure icons array exists and is valid
    if (!row.icons || !Array.isArray(row.icons)) {
      console.warn('Cannot remove icon: icons array not found or not an array');
      return;
    }

    // Check if the icon index is valid
    if (iconIndex < 0 || iconIndex >= row.icons.length) {
      console.warn(
        `Cannot remove icon: index ${iconIndex} out of bounds (0-${row.icons.length - 1})`
      );
      return;
    }

    // Remove the icon
    row.icons.splice(iconIndex, 1);

    // Update config
    this._updateConfig(newConfig);

    // Clear expanded icon if it was the one removed
    if (
      this._expandedIcon &&
      this._expandedIcon.rowId === rowId &&
      this._expandedIcon.iconIndex === iconIndex
    ) {
      this._expandedIcon = null;
    } else if (
      this._expandedIcon &&
      this._expandedIcon.rowId === rowId &&
      this._expandedIcon.iconIndex > iconIndex
    ) {
      // Adjust index if we removed an icon before the expanded one
      this._expandedIcon = {
        rowId: this._expandedIcon.rowId,
        iconIndex: this._expandedIcon.iconIndex - 1,
      };
    }

    // Force an update to reflect changes immediately
    this.requestUpdate();
  }

  private _toggleIconEdit(rowId: string, iconIndex: number) {
    if (
      this._expandedIcon &&
      this._expandedIcon.rowId === rowId &&
      this._expandedIcon.iconIndex === iconIndex
    ) {
      this._expandedIcon = null;
    } else {
      this._expandedIcon = { rowId, iconIndex };
    }
  }

  private _updateIconConfig(rowId: string, iconIndex: number, updates: Partial<IconConfig>) {
    // Create a deep copy of the config to avoid object reference issues
    const newConfig = JSON.parse(JSON.stringify(this.config));

    // Ensure icon_rows exists
    if (!newConfig.icon_rows) {
      newConfig.icon_rows = [];
      return; // No rows to update
    }

    // Find the row
    const rowIndex = newConfig.icon_rows.findIndex(row => row.id === rowId);

    if (rowIndex >= 0 && iconIndex >= 0 && iconIndex < newConfig.icon_rows[rowIndex].icons.length) {
      // Store old values for comparison
      const oldIcon = newConfig.icon_rows[rowIndex].icons[iconIndex];
      const oldTextPosition = oldIcon.text_position;
      const oldVerticalAlignment = oldIcon.vertical_alignment;
      const oldIconSize = oldIcon.icon_size;
      const oldTextSize = oldIcon.text_size;

      // Log the icon config update
      console.log(`[EDITOR] Updating icon ${rowId}/${iconIndex}:`, updates);

      // Update the icon with the new properties
      newConfig.icon_rows[rowIndex].icons[iconIndex] = {
        ...newConfig.icon_rows[rowIndex].icons[iconIndex],
        ...updates,
      };

      // Log appearance changes
      if (updates.text_position && updates.text_position !== oldTextPosition) {
        console.log(
          `[EDITOR] Text position changed from ${oldTextPosition || 'default'} to ${updates.text_position}`
        );
      }

      if (updates.vertical_alignment && updates.vertical_alignment !== oldVerticalAlignment) {
        console.log(
          `[EDITOR] Vertical alignment changed from ${oldVerticalAlignment || 'default'} to ${updates.vertical_alignment}`
        );
      }

      if (updates.icon_size && updates.icon_size !== oldIconSize) {
        console.log(
          `[EDITOR] Icon size changed from ${oldIconSize || 'default'} to ${updates.icon_size}`
        );
      }

      if (updates.text_size && updates.text_size !== oldTextSize) {
        console.log(
          `[EDITOR] Text size changed from ${oldTextSize || 'default'} to ${updates.text_size}`
        );
      }

      // Update config
      this._updateConfig(newConfig);

      // Force update to the preview
      this.requestUpdate();
    }
  }

  // Helper methods for spacing and alignment
  private _getAlignmentLabel(alignment: string): string {
    const option = ICON_ALIGNMENT_OPTIONS.find(opt => opt.value === alignment);
    return option ? option.label : 'Left';
  }

  private _getSpacingValue(spacing: string): string {
    switch (spacing) {
      case 'none':
        return '0';
      case 'small':
        return '8px';
      case 'medium':
        return '16px';
      case 'large':
        return '24px';
      default:
        return '16px';
    }
  }

  // Drag and drop methods for icon rows
  private _handleIconRowDragStart(e: DragEvent, rowId: string) {
    this._draggedIconRow = rowId;
    if (e.dataTransfer) {
      e.dataTransfer.effectAllowed = 'move';
      e.dataTransfer.setData('application/ultra-vehicle-row', rowId);
    }
  }

  private _handleIconRowDragEnd() {
    this._draggedIconRow = null;
    this._dropTargetRow = null;
  }

  private _handleIconRowDragOver(e: DragEvent, rowId: string) {
    e.preventDefault();
    if (e.dataTransfer) {
      e.dataTransfer.dropEffect = 'move';
    }

    if (this._draggedIconRow && this._draggedIconRow !== rowId) {
      this._dropTargetRow = rowId;
    }
  }

  private _handleIconRowDragLeave() {
    this._dropTargetRow = null;
  }

  private _handleIconRowDrop(e: DragEvent, rowId: string) {
    e.preventDefault();

    const data = e.dataTransfer?.getData('application/ultra-vehicle-row');
    if (data && data === this._draggedIconRow && this._draggedIconRow !== rowId) {
      this._rearrangeIconRows(this._draggedIconRow, rowId);
    }

    this._draggedIconRow = null;
    this._dropTargetRow = null;
  }

  // Drag and drop methods for icons
  private _handleIconDragStart(e: DragEvent, rowId: string, iconIndex: number) {
    this._draggedIcon = { rowId, iconIndex };
    if (e.dataTransfer) {
      e.dataTransfer.effectAllowed = 'move';
      e.dataTransfer.setData(
        'application/ultra-vehicle-icon',
        JSON.stringify({ rowId, iconIndex })
      );
    }
  }

  private _handleIconDragEnd() {
    this._draggedIcon = null;
    this._dropTargetIcon = null;
  }

  private _handleIconDragOver(e: DragEvent, rowId: string, iconIndex: number) {
    e.preventDefault();
    if (e.dataTransfer) {
      e.dataTransfer.dropEffect = 'move';
    }

    if (
      this._draggedIcon &&
      (this._draggedIcon.rowId !== rowId || this._draggedIcon.iconIndex !== iconIndex)
    ) {
      this._dropTargetIcon = { rowId, iconIndex };
    }
  }

  private _handleIconDragLeave() {
    this._dropTargetIcon = null;
  }

  private _handleIconDrop(e: DragEvent, rowId: string, iconIndex: number) {
    e.preventDefault();

    const data = e.dataTransfer?.getData('application/ultra-vehicle-icon');
    if (data && this._draggedIcon) {
      const { rowId: fromRowId, iconIndex: fromIconIndex } = JSON.parse(data);

      if (fromRowId === rowId && fromIconIndex === iconIndex) {
        return; // Dropped on itself
      }

      this._rearrangeIcons(fromRowId, fromIconIndex, rowId, iconIndex);
    }

    this._draggedIcon = null;
    this._dropTargetIcon = null;
  }

  private _rearrangeIcons(
    fromRowId: string,
    fromIconIndex: number,
    toRowId: string,
    toIconIndex: number
  ) {
    const iconRows = [...(this.config.icon_rows || [])];
    const fromRowIndex = iconRows.findIndex(row => row.id === fromRowId);
    const toRowIndex = iconRows.findIndex(row => row.id === toRowId);

    if (fromRowIndex >= 0 && toRowIndex >= 0) {
      // Get the icon to move
      const [movedIcon] = iconRows[fromRowIndex].icons.splice(fromIconIndex, 1);

      // Insert at the new position
      iconRows[toRowIndex].icons.splice(toIconIndex, 0, movedIcon);

      this._updateConfig({ icon_rows: iconRows });

      // Update expanded icon reference if needed
      if (this._expandedIcon) {
        if (
          this._expandedIcon.rowId === fromRowId &&
          this._expandedIcon.iconIndex === fromIconIndex
        ) {
          // The expanded icon was moved
          this._expandedIcon = { rowId: toRowId, iconIndex: toIconIndex };
        } else if (
          this._expandedIcon.rowId === fromRowId &&
          this._expandedIcon.iconIndex > fromIconIndex
        ) {
          // An icon was removed before the expanded icon in the same row
          this._expandedIcon = {
            rowId: this._expandedIcon.rowId,
            iconIndex: this._expandedIcon.iconIndex - 1,
          };
        } else if (
          this._expandedIcon.rowId === toRowId &&
          this._expandedIcon.iconIndex >= toIconIndex
        ) {
          // An icon was added before the expanded icon in the same row
          this._expandedIcon = {
            rowId: this._expandedIcon.rowId,
            iconIndex: this._expandedIcon.iconIndex + 1,
          };
        }
      }
    }
  }

  render() {
    if (!this.config) {
      return nothing;
    }

    return html`
      <div class="card-config">
        <div class="tabs">
          <div
            class="tab ${this.activeTab === 'settings' ? 'active' : ''}"
            @click="${() => (this.activeTab = 'settings')}"
          >
            Settings
          </div>
          <div
            class="tab ${this.activeTab === 'bars' ? 'active' : ''}"
            @click="${() => (this.activeTab = 'bars')}"
          >
            Bars
          </div>
          <div
            class="tab ${this.activeTab === 'icons' ? 'active' : ''}"
            @click="${() => (this.activeTab = 'icons')}"
          >
            Icons
          </div>
          <div
            class="tab ${this.activeTab === 'customize' ? 'active' : ''}"
            @click="${() => (this.activeTab = 'customize')}"
          >
            Customize
          </div>
        </div>

        ${this.activeTab === 'settings' ? this._renderSettingsTab() : ''}
        ${this.activeTab === 'bars' ? this._renderBarsTab() : ''}
        ${this.activeTab === 'icons' ? this._renderIconsTab() : ''}
        ${this.activeTab === 'customize'
          ? this._renderCustomizeTab() // Replace the placeholder with the actual function call
          : ''}
      </div>
    `;
  }

  static get styles() {
    return css`
      /* Base layout */
      .card-config {
        display: flex;
        flex-direction: column;
      }

      /* Tab navigation */
      .tabs {
        display: flex;
        margin-bottom: 16px;
      }
      .tab {
        padding: 8px 16px;
        cursor: pointer;
        border-bottom: 2px solid transparent;
      }
      .tab.active {
        border-bottom: 2px solid var(--primary-color);
      }

      /* Content sections */
      .tab-content,
      .section-content {
        display: flex;
        flex-direction: column;
        gap: 16px;
      }

      .settings-section {
        margin-bottom: 24px;
        border: 1px solid var(--divider-color);
        border-radius: 8px;
        overflow: hidden;
        background-color: var(--secondary-background-color, #2d2d2d);
      }

      .section-header {
        font-size: 1.1em;
        font-weight: 500;
        padding: 8px 0;
        border-bottom: 1px solid var(--divider-color);
        margin-bottom: 8px;
      }

      .settings-section .section-header {
        background-color: var(--primary-background-color, #202020);
        padding: 12px 16px;
        font-weight: 500;
        border-bottom: 1px solid var(--divider-color);
      }

      .settings-content {
        padding: 16px 18px;
        display: grid;
      }

      /* Forms and inputs */
      ha-form {
        padding: 0;
        margin-bottom: 16px;
      }

      ha-form[.schema*='Card Title'] ha-selector {
        padding-bottom: 8px;
      }

      .mdc-select.mdc-select--filled {
        margin-bottom: 32px !important;
      }

      ha-selector {
        margin-bottom: 16px;
        --selector-label-spacing: 8px;
        --selector-padding: 8px 0;
      }

      ha-selector ha-slider {
        width: 100%;
      }

      ha-selector[data-name='vehicle_image_width'],
      ha-selector[data-name='action_image_width'] {
        margin-top: 16px;
        padding-bottom: 8px;
      }

      ha-select {
        width: 100%;
        margin: 8px 16px;
      }

      .upload-container {
        margin: 8px 0 16px 0;
        padding: 0 16px;
      }

      .image-preview {
        margin-top: 16px;
        max-width: 100%;
        border-radius: 8px;
        overflow: hidden;
      }

      .image-preview img {
        max-width: 100%;
        max-height: 200px;
        object-fit: contain;
      }

      /* Bar containers and items */
      .bars-description {
        color: var(--secondary-text-color);
        font-size: 0.8em;
        margin-bottom: 16px;
      }

      .bars-container,
      .bar-list {
        display: flex;
        flex-direction: column;
        gap: 8px;
        margin-bottom: 16px;
      }

      .bar-list {
        margin-top: 16px;
      }

      .mini-bar-list {
        margin-top: 8px;
      }

      /* Bar styling */
      .bar,
      .mini-bar {
        margin-bottom: 8px;
        border: 1px solid var(--divider-color);
        border-radius: 8px;
        background-color: var(--secondary-background-color);
        overflow: hidden;
        box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1);
      }

      .bar.expanded,
      .mini-bar.expanded {
        box-shadow: 0 2px 8px rgba(0, 0, 0, 0.2);
        border-color: var(--primary-color);
      }

      .bar-header,
      .mini-bar-header {
        display: flex;
        align-items: center;
        padding: 12px 16px;
        cursor: pointer;
        background-color: var(--card-background-color, rgba(0, 0, 0, 0.05));
      }

      .mini-bar-header {
        padding: 0px 12px;
        min-height: 48px;
      }

      .bar-content,
      .mini-bar-content {
        padding: 16px;
      }

      .mini-bar-content {
        padding: 16px;
      }

      .bar-title {
        flex-grow: 1;
        font-weight: 500;
        display: flex;
        align-items: center;
        overflow: hidden;
      }

      .bar-entity,
      .bar-details {
        display: block;
        margin-left: 24px;
        max-width: 200px;
        overflow: hidden;
        text-overflow: ellipsis;
        white-space: nowrap;
        opacity: 0.7;
        font-size: 0.9em;
      }

      .bar-details {
        margin-left: 8px;
      }

      .bar-actions {
        display: flex;
        gap: 8px;
        flex-shrink: 0;
      }

      .bar-grip,
      .drag-handle {
        color: var(--secondary-text-color);
        margin-right: 8px;
        cursor: grab;
        display: flex;
        align-items: center;
        opacity: 0.7;
      }

      .bar-grip:hover,
      .drag-handle:hover,
      .draggable-section:hover .drag-handle {
        opacity: 1;
        color: var(--primary-color);
      }

      .bar-icon-preview {
        display: flex;
        align-items: center;
        justify-content: center;
        margin-right: 8px;
        min-width: 28px;
        height: 28px;
      }

      /* Add buttons */
      .add-bar-container {
        display: flex;
        justify-content: center;
        margin: 16px 0;
        width: 100%;
      }

      .add-bar-button,
      .add-icon-button {
        width: auto;
        background-color: var(--primary-color);
        border-radius: 4px;
        cursor: pointer;
        display: flex;
        align-items: center;
        justify-content: center;
        box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
      }

      .add-icon-button {
        width: 100%;
        margin-top: 8px;
      }

      .add-icon {
        --mdc-icon-size: 20px;
        margin-right: 4px;
        color: white;
      }

      ha-button.add-bar-button {
        --mdc-theme-primary: var(--primary-text-color);
        --mdc-theme-on-primary: white;
        color: white !important;
        height: 36px;
        font-weight: 500;
      }

      ha-button.add-bar-button::part(button) {
        color: white;
      }

      /* Section groups and subsections */
      .section-group {
        margin-bottom: 20px;
        border: 1px solid var(--divider-color);
        border-radius: 8px;
        overflow: hidden;
        background-color: var(--card-background-color, #1c1c1c);
        padding: 16px;
      }

      .subsection-header {
        display: flex;
        justify-content: space-between;
        align-items: center;
        padding: 10px 16px;
        background-color: var(--secondary-background-color);
        font-weight: 500;
        border-bottom: 1px solid var(--divider-color);
      }

      .side-disabled {
        padding: 16px;
        color: var(--secondary-text-color);
        font-style: italic;
        text-align: center;
      }

      .helper-text {
        color: var(--secondary-text-color);
        font-size: 0.8em;
        padding: 0 16px 16px;
      }

      .alignment-control {
        padding: 0 16px 16px;
        border-top: 1px solid var(--divider-color);
        margin-top: 8px;
        padding-top: 16px;
      }

      .alignment-control ha-form {
        padding: 0;
      }

      .section-group ha-form ha-form {
        padding: 0;
      }

      /* Color pickers */
      .color-pickers-grid {
        display: grid;
        grid-template-columns: 1fr 1fr;
        gap: 16px;
        margin-top: 16px;
        padding: 0 8px;
      }

      .color-picker-item {
        position: relative;
        display: flex;
        align-items: center;
        margin-bottom: 16px;
        width: 100%;
      }

      .color-picker-item ultra-vehicle-color-picker {
        flex-grow: 1;
      }

      .color-reset-button {
        margin-left: 8px;
        --mdc-icon-size: 20px;
        color: var(--secondary-text-color);
        opacity: 0.8;
        align-self: center;
      }

      .color-reset-button:hover {
        opacity: 1;
        color: var(--primary-color);
      }

      .color-picker-container {
        margin-top: 16px;
      }

      .color-picker-header {
        display: flex;
        justify-content: space-between;
        align-items: center;
        margin-bottom: 4px;
      }

      .color-picker-label {
        font-weight: 500;
        margin-bottom: 4px;
      }

      .color-picker-content {
        display: flex;
        align-items: center;
        gap: 8px;
      }

      .color-preview {
        width: 32px;
        height: 32px;
        border-radius: 16px;
        overflow: hidden;
        box-shadow: 0 1px 3px rgba(0, 0, 0, 0.2);
      }

      /* Action content */
      .action-content {
        margin-top: 8px;
      }

      .action-content ha-form {
        margin-bottom: 16px;
      }

      /* Icon styles */
      .icon-rows-container {
        display: flex;
        flex-direction: column;
        gap: 16px;
        margin-top: 16px;
      }

      .icon-row {
        display: flex;
        flex-wrap: wrap;
        margin: 0 auto;
      }

      .icon-container {
        display: flex;
        flex-direction: column;
        align-items: center;
        padding: 8px;
        cursor: pointer;
        transition: all 0.2s ease;
        border-radius: 4px;
      }

      .icon-container:hover {
        background: rgba(var(--rgb-primary-color), 0.1);
      }

      .icon-container ha-icon {
        font-size: 24px;
        margin-bottom: 4px;
      }

      .icon-label,
      .icon-state {
        text-align: center;
        max-width: 100%;
        width: 100%;
        overflow: visible;
        word-wrap: break-word;
        word-break: break-word;
        white-space: normal !important;
      }

      .icon-label {
        font-size: 0.85em;
        margin-top: 4px;
        margin-bottom: 2px;
      }

      .icon-state {
        font-size: 0.75em;
        color: var(--secondary-text-color);
      }

      /* Preview containers */
      .icon-preview-container {
        margin-top: 16px;
        padding: 16px;
        background-color: var(--card-background-color, rgba(0, 0, 0, 0.05));
        border-radius: 8px;
        border: 1px solid var(--divider-color);
      }

      .preview-header {
        font-weight: 500;
        margin-bottom: 16px;
        text-align: center;
      }

      .icon-states-preview {
        display: flex;
        justify-content: space-around;
      }

      .preview-state {
        display: flex;
        flex-direction: column;
        align-items: center;
        padding: 16px;
      }

      .preview-state ha-icon {
        font-size: 32px;
        margin-bottom: 8px;
      }

      .preview-label {
        font-size: 14px;
        margin-top: 4px;
      }

      .preview-name {
        font-size: 14px;
        font-weight: 500;
        margin-top: 6px;
        text-align: center;
      }

      .preview-state-value {
        font-size: 13px;
        color: var(--secondary-text-color);
        margin-top: 2px;
        text-align: center;
      }

      /* Crop styles */
      .crop-accordion {
        margin-top: 16px;
        border: 1px solid var(--divider-color);
        border-radius: 8px;
        overflow: hidden;
      }

      .crop-accordion-header {
        display: flex;
        justify-content: space-between;
        align-items: center;
        padding: 12px 16px;
        background-color: var(--card-background-color, rgba(0, 0, 0, 0.05));
        cursor: pointer;
        font-weight: 500;
      }

      .crop-controls {
        padding: 16px;
      }

      .crop-sliders {
        display: grid;
        grid-template-columns: 1fr;
        gap: 16px;
      }

      .crop-slider {
        display: flex;
        align-items: center;
        gap: 8px;
      }

      .crop-label {
        min-width: 50px;
        margin-bottom: 4px;
        font-weight: 500;
      }

      .crop-value {
        min-width: 36px;
        text-align: right;
      }

      .crop-reset {
        display: flex;
        align-items: center;
        margin-top: 16px;
      }

      .crop-explanation {
        display: flex;
        align-items: center;
        gap: 8px;
        margin-top: 12px;
        color: var(--secondary-text-color);
        font-size: 0.9em;
        padding: 8px;
        background: rgba(var(--rgb-primary-color), 0.05);
        border-radius: 4px;
      }

      .crop-explanation ha-icon {
        color: var(--primary-color);
      }

      .crop-input-row {
        display: flex;
        flex-direction: row;
        justify-content: space-between;
        gap: 8px;
        margin-bottom: 16px;
      }

      .crop-input-field {
        display: flex;
        flex-direction: column;
        align-items: center;
        flex: 1;
      }

      .crop-input-field ha-textfield {
        width: 100%;
        min-width: 60px;
      }

      .crop-unit {
        margin-top: 4px;
        font-size: 0.9em;
        color: var(--secondary-text-color);
      }

      /* Gradient editor */
      .gradient-editor-section {
        margin-top: 16px;
        padding: 16px;
        background-color: var(--card-background-color, #303030);
        border-radius: 8px;
        border: 1px solid var(--divider-color);
      }

      .gradient-header {
        font-size: 1.1em;
        font-weight: 500;
        padding: 0 0 12px 0;
        margin-bottom: 12px;
        display: flex;
        justify-content: space-between;
        align-items: center;
        border-bottom: 1px solid var(--divider-color);
      }

      .gradient-preview {
        height: 32px;
        border-radius: 16px;
        margin: 16px 0 24px;
        border: 1px solid var(--divider-color);
        overflow: hidden; /* Ensure colors don't bleed outside */
        box-shadow: 0 1px 3px rgba(0, 0, 0, 0.2);
      }

      .gradient-stops-container {
        display: flex;
        flex-direction: column;
        gap: 12px;
      }

      .gradient-stop-row {
        display: grid;
        grid-template-columns: 40px 60px 1fr 60px auto;
        gap: 12px;
        align-items: center;
        padding: 12px;
        border-radius: 8px;
        border: 1px solid var(--divider-color);
        background: var(--card-background-color, rgba(0, 0, 0, 0.05));
      }

      .gradient-slider-container {
        width: 100%;
      }

      .gradient-stop-row.drop-target {
        background: var(--primary-color-lighten, rgba(var(--rgb-primary-color), 0.1));
        border-color: var(--primary-color);
      }

      .gradient-color-picker {
        width: 48px;
        height: 48px;
      }

      .position-label {
        min-width: 48px;
        text-align: center;
        font-weight: 500;
      }

      .drag-handle {
        cursor: grab;
        color: var(--secondary-text-color);
        display: flex;
        justify-content: center;
        width: 24px;
      }

      .gradient-stop-row:hover .drag-handle {
        color: var(--primary-text-color);
      }

      .description {
        font-size: 14px;
        color: var(--secondary-text-color);
        margin-bottom: 8px;
      }

      /* Drag and drop styles */
      .bar.dragging,
      .mini-bar.dragging,
      .draggable-section.dragging {
        opacity: 0.5;
        transform: scale(0.98);
        box-shadow: 0 5px 10px rgba(0, 0, 0, 0.2);
        border: 1px dashed var(--primary-color);
        z-index: 10;
        background-color: var(--card-background-color, #fff);
      }

      .bar.drop-target,
      .mini-bar.drop-target,
      .gradient-stop-row.drop-target,
      .draggable-section.drag-over {
        border: 2px dashed var(--primary-color);
        background-color: rgba(var(--rgb-primary-color), 0.1);
        transform: translateY(-2px);
      }

      /* Draggable section styles */
      .draggable-sections-container {
        display: flex;
        flex-direction: column;
        gap: 16px;
        margin-top: 16px;
      }

      .draggable-sections {
        display: flex;
        flex-direction: column;
        gap: 8px;
        margin-bottom: 16px;
        border: 1px solid var(--divider-color);
        border-radius: 8px;
        padding: 8px;
        background-color: var(--card-background-color, rgba(0, 0, 0, 0.05));
      }

      .draggable-sections.two-columns {
        flex-direction: row;
        flex-wrap: wrap;
      }

      .draggable-sections.two-columns .draggable-section {
        width: calc(50% - 4px);
        box-sizing: border-box;
      }

      .draggable-sections.two-columns .draggable-section[data-section='image'],
      .draggable-sections.two-columns .draggable-section[data-section='title'] {
        width: 100%;
      }

      .draggable-section {
        border: 1px solid var(--divider-color);
        background-color: var(--card-background-color, #fff);
        border-radius: 6px;
        padding: 10px 12px;
        cursor: grab;
        transition:
          background-color 0.2s ease,
          transform 0.2s ease,
          box-shadow 0.2s ease;
        display: flex;
        align-items: center;
        margin-bottom: 4px;
        box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1);
        position: relative;
        z-index: 1;
        min-width: 120px;
        white-space: nowrap;
        flex-wrap: nowrap;
      }

      .draggable-section:hover {
        background-color: var(--secondary-background-color);
        transform: translateY(-2px);
        box-shadow: 0 3px 6px rgba(0, 0, 0, 0.15);
        z-index: 2;
      }

      .draggable-section:active {
        cursor: grabbing;
      }

      .section-info {
        display: flex;
        align-items: center;
        gap: 8px;
        font-weight: 500;
        white-space: nowrap;
        flex-wrap: nowrap;
        overflow: hidden;
      }

      .section-info ha-icon {
        color: var(--primary-color);
      }

      /* Column styles */
      .column-headers {
        display: flex;
        justify-content: space-between;
        margin-bottom: 8px;
        gap: 16px;
      }

      .column-header {
        flex: 1;
        text-align: center;
        font-weight: 500;
        color: var(--primary-color);
        padding: 8px;
        background-color: var(--secondary-background-color);
        border-radius: 8px 8px 0 0;
        border: 1px solid var(--divider-color);
        border-bottom: none;
      }

      .columns-wrapper {
        display: flex;
        flex-direction: column;
        gap: 24px;
        width: 100%;
      }

      .column-container {
        flex: 1;
        display: flex;
        flex-direction: column;
        gap: 8px;
        min-height: 120px;
        padding: 8px;
        border: 1px solid var(--divider-color);
        border-radius: 0 0 8px 8px;
        background-color: var(--card-background-color, rgba(0, 0, 0, 0.05));
        transition: all 0.2s ease;
        position: relative;
      }

      .empty-column-message {
        position: absolute;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        color: var(--secondary-text-color);
        opacity: 0.7;
        font-style: italic;
        pointer-events: none;
      }

      .column-container.column-drag-over {
        border: 2px dashed var(--primary-color);
        background-color: rgba(var(--rgb-primary-color), 0.1);
        padding: 7px;
        transform: scale(1.02);
        box-shadow: 0 0 10px rgba(var(--rgb-primary-color), 0.3);
        z-index: 1;
      }

      .column-container.left-column.column-drag-over {
        border-right-width: 1px;
      }

      .column-container.right-column.column-drag-over {
        border-left-width: 1px;
      }

      /* Card preview */
      .card-title {
        text-align: center;
      }

      .card-header {
        display: flex;
      }

      .card-header.left,
      .card-title.left {
        justify-content: flex-start;
        text-align: left;
      }

      .card-header.center,
      .card-title.center {
        justify-content: center;
        text-align: center;
      }

      .card-header.right,
      .card-title.right {
        justify-content: flex-end;
        text-align: right;
      }

      .description {
        font-size: 14px;
        color: var(--secondary-text-color);
        margin-bottom: 8px;
      }

      /* Utility classes */
      .instructions {
        color: var(--secondary-text-color);
        font-size: 0.9em;
        margin-bottom: 16px;
      }

      .row {
        margin-bottom: 16px;
        width: 100%;
      }

      .section-info ha-icon {
        color: var(--primary-color);
      }

      .section-name {
        flex: 1;
        overflow: hidden;
        text-overflow: ellipsis;
        white-space: nowrap;
      }

      .section-visibility-toggle {
        margin-left: auto;
        cursor: pointer;
        opacity: 0.7;
      }

      .section-visibility-toggle:hover {
        opacity: 1;
      }

      /* Column styles */
      .column-headers {
        display: flex;
        justify-content: space-between;
        margin-bottom: 8px;
        gap: 16px;
      }

      .column-header {
        flex: 1;
        text-align: center;
        font-weight: 500;
        color: var(--primary-color);
        padding: 8px;
        background-color: var(--secondary-background-color);
        border-radius: 8px 8px 0 0;
        border: 1px solid var(--divider-color);
        border-bottom: none;
      }

      .columns-wrapper {
        display: flex;
        flex-direction: column;
        gap: 24px;
        width: 100%;
      }

      .column-container {
        flex: 1;
        display: flex;
        flex-direction: column;
        gap: 8px;
        min-height: 120px;
        padding: 8px;
        border: 1px solid var(--divider-color);
        border-radius: 0 0 8px 8px;
        background-color: var(--card-background-color, rgba(0, 0, 0, 0.05));
        transition: all 0.2s ease;
        position: relative;
      }

      .empty-column-message {
        position: absolute;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        color: var(--secondary-text-color);
        opacity: 0.7;
        font-style: italic;
        pointer-events: none;
      }

      .column-container.column-drag-over {
        border: 2px dashed var(--primary-color);
        background-color: rgba(var(--rgb-primary-color), 0.1);
        padding: 7px;
        transform: scale(1.02);
        box-shadow: 0 0 10px rgba(var(--rgb-primary-color), 0.3);
        z-index: 1;
      }

      .column-container.left-column.column-drag-over {
        border-right-width: 1px;
      }

      .column-container.right-column.column-drag-over {
        border-left-width: 1px;
      }

      /* Card preview */
      .card-title {
        text-align: center;
      }

      .card-header {
        display: flex;
      }

      .card-header.left,
      .card-title.left {
        justify-content: flex-start;
        text-align: left;
      }

      .card-header.center,
      .card-title.center {
        justify-content: center;
        text-align: center;
      }

      .card-header.right,
      .card-title.right {
        justify-content: flex-end;
        text-align: right;
      }

      .description {
        font-size: 14px;
        color: var(--secondary-text-color);
        margin-bottom: 8px;
      }

      /* Utility classes */
      .instructions {
        color: var(--secondary-text-color);
        font-size: 0.9em;
        margin-bottom: 16px;
      }

      .row {
        margin-bottom: 16px;
        width: 100%;
      }

      .icon-state-section {
        margin-bottom: 16px;
        border: 1px solid var(--divider-color);
        border-radius: 8px;
        overflow: hidden;
        background-color: var(--card-background-color, rgba(255, 255, 255, 0.1));
      }

      .icon-state-header {
        display: flex;
        justify-content: space-between;
        align-items: center;
        padding: 12px 16px;
        background-color: var(--secondary-background-color);
        border-bottom: 1px solid var(--divider-color);
      }

      .icon-state-title {
        font-weight: 500;
        color: var(--primary-color);
      }

      .icon-state-preview {
        display: flex;
        flex-direction: column;
        align-items: center;
        min-width: 60px;
      }

      .icon-state-preview ha-icon {
        font-size: 24px;
        margin-bottom: 4px;
      }

      .icon-state-content {
        padding: 16px 24px;
      }

      .active-section {
        border-left: 3px solid var(--primary-color);
      }

      .inactive-section {
        border-left: 3px solid var(--secondary-text-color);
      }

      /* Form descriptions */
      ha-form .description {
        color: var(--secondary-text-color);
        font-size: 0.85em;
        margin-top: 2px;
        margin-bottom: 12px;
        padding: 0 8px;
        line-height: 1.3;
        width: 100%;
        display: block;
      }

      /* Make field labels more visible */
      ha-form mwc-formfield {
        font-weight: 500;
        color: var(--primary-text-color);
        margin-top: 8px;
      }

      /* Current entity state display */
      .current-entity-state {
        margin-bottom: 16px;
        padding: 12px;
        border-radius: 8px;
        background-color: var(--card-background-color, rgba(0, 0, 0, 0.05));
        border: 1px solid var(--divider-color);
      }

      .entity-state-header {
        display: flex;
        justify-content: space-between;
        align-items: center;
      }

      .entity-state-value {
        font-weight: bold;
        color: var(--primary-color);
        padding: 4px 8px;
        border-radius: 4px;
        background-color: rgba(var(--rgb-primary-color), 0.1);
      }
    `;
  }

  firstUpdated() {
    // Initialize entities list from hass
    this._refreshEntityList();

    // Add click listener to close dropdown when clicking outside
    document.addEventListener('click', e => {
      if (!this.shadowRoot?.contains(e.target as Node)) {
        this._showEntityList = false;
      }
    });

    // Load cropperjs dynamically
    this._loadCropperJS();
  }

  private _refreshEntityList() {
    if (!this.hass) return;

    // Create a list of all entities with friendly names
    this._entities = Object.keys(this.hass.states).map(entityId => ({
      entity_id: entityId,
      friendly_name: this.hass.states[entityId]?.attributes?.friendly_name || '',
    }));
  }

  private _onEntityInputChange(ev: Event) {
    const input = ev.target as HTMLInputElement;
    const field = input.dataset.field || '';
    this._entityFilter = input.value;
    this._activeField = field;
    this._showEntityList = true;

    // Also update the config directly for manual typing
    if (field.includes('.')) {
      // Handle nested properties like 'bars.0.entity'
      const parts = field.split('.');
      if (parts[0] === 'bars' && parts.length === 3) {
        const index = parseInt(parts[1]);
        const property = parts[2];
        const bars = [...(this.config.bars || [])];

        if (bars[index]) {
          bars[index] = {
            ...bars[index],
            [property]: input.value,
          };
          this._updateConfig({ bars });
        }
      }
    } else {
      this._updateConfig({ [field]: input.value });
    }
  }

  private _onEntityFocus(ev: Event, field: string) {
    ev.stopPropagation();
    this._activeField = field;
    this._showEntityList = true;
    this._entityFilter = (ev.target as HTMLInputElement).value;
    this._refreshEntityList();
  }

  private _getFilteredEntities() {
    if (!this._entityFilter || this._entityFilter.length < 2) {
      return this._entities.sort((a, b) => a.entity_id.localeCompare(b.entity_id)).slice(0, 15); // Show first 15 by default, sorted alphabetically
    }

    const filter = this._entityFilter.toLowerCase();
    return this._entities
      .filter(
        entity =>
          entity.entity_id.toLowerCase().includes(filter) ||
          entity.friendly_name.toLowerCase().includes(filter)
      )
      .sort((a, b) => {
        // Sort exact matches first, then by whether they start with the filter, then alphabetically
        const aExact = a.entity_id.toLowerCase() === filter;
        const bExact = b.entity_id.toLowerCase() === filter;
        if (aExact && !bExact) return -1;
        if (!aExact && bExact) return 1;

        const aStartsWith = a.entity_id.toLowerCase().startsWith(filter);
        const bStartsWith = b.entity_id.toLowerCase().startsWith(filter);
        if (aStartsWith && !bStartsWith) return -1;
        if (!aStartsWith && bStartsWith) return 1;

        return a.entity_id.localeCompare(b.entity_id);
      })
      .slice(0, 15); // Limit to 15 results
  }

  private _selectEntity(field: string, entityId: string) {
    // Support for nested fields like 'bars.0.entity'
    if (field.includes('.')) {
      const parts = field.split('.');
      if (parts[0] === 'bars' && parts.length === 3) {
        const index = parseInt(parts[1]);
        const property = parts[2];
        const bars = [...(this.config.bars || [])];

        if (bars[index]) {
          bars[index] = {
            ...bars[index],
            [property]: entityId,
          };
          this._updateConfig({ bars });
        }
      }
    } else {
      this._updateConfig({ [field]: entityId });
    }

    this._showEntityList = false;
  }

  private _handleDragStart(e: DragEvent, index: number) {
    this._draggedBarIndex = index;
    if (e.dataTransfer) {
      e.dataTransfer.effectAllowed = 'move';
      e.dataTransfer.setData('text/plain', index.toString());

      // Add a ghost image
      const draggedEl = e.currentTarget as HTMLElement;
      if (draggedEl && e.dataTransfer) {
        const rect = draggedEl.getBoundingClientRect();
        const ghostEl = draggedEl.cloneNode(true) as HTMLElement;

        // Style the ghost element
        ghostEl.style.width = `${rect.width}px`;
        ghostEl.style.opacity = '0.7';
        ghostEl.style.position = 'absolute';
        ghostEl.style.top = '-1000px';
        ghostEl.style.border = '2px dashed var(--primary-color)';

        document.body.appendChild(ghostEl);
        e.dataTransfer.setDragImage(ghostEl, 20, 20);

        // Clean up the ghost element after a short delay
        setTimeout(() => {
          document.body.removeChild(ghostEl);
        }, 100);
      }
    }
  }

  private _handleDragEnd() {
    this._draggedBarIndex = null;
    this._dropTargetIndex = null;
  }

  private _handleDragOver(e: DragEvent, index: number) {
    e.preventDefault();
    if (e.dataTransfer) {
      e.dataTransfer.dropEffect = 'move';
    }
    if (this._draggedBarIndex !== index) {
      this._dropTargetIndex = index;
    }
  }

  private _handleDragLeave() {
    this._dropTargetIndex = null;
  }

  private _handleDrop(e: DragEvent, _index: number) {
    e.preventDefault();

    const data = e.dataTransfer?.getData('text/plain');
    if (data && this._draggedBarIndex !== null) {
      const newIndex = parseInt(data);
      this._rearrangeBars(this._draggedBarIndex, newIndex);
    }

    this._draggedBarIndex = null;
    this._dropTargetIndex = null;
  }

  private _rearrangeBars(fromIndex: number, toIndex: number) {
    const bars = [...(this.config.bars || [])];
    // Check if indexes are valid before modifying the array
    if (fromIndex < 0 || fromIndex >= bars.length || toIndex < 0 || toIndex >= bars.length) {
      console.error('Invalid bar indexes for rearrangement', {
        fromIndex,
        toIndex,
        totalBars: bars.length,
      });
      return;
    }

    const [movedBar] = bars.splice(fromIndex, 1);
    bars.splice(toIndex, 0, movedBar);

    // Update expanded bar index if needed
    if (this._expandedBar === fromIndex) {
      this._expandedBar = toIndex;
    } else if (this._expandedBar !== null && this._expandedBar > fromIndex) {
      this._expandedBar = this._expandedBar - 1;
    }

    this._updateConfig({ bars });
  }

  private _createDefaultConfig(): UltraVehicleCardConfig {
    return {
      title: 'Vehicle Title',
      title_alignment: 'center',
      vehicle_image_type: 'upload',
      vehicle_image_width: 100,
      formatted_entities: true,
      show_units: true,
      show_location: true,
      show_mileage: true,
      show_car_state: true,
      bars: [],
      icon_rows: [],
      sections_order: ['title', 'image', 'info', 'bars', 'icons'],
    };
  }

  private async _handleFileInputChange(e: Event) {
    const input = e.target as HTMLInputElement;
    if (!input.files || !input.files[0]) {
      console.log('[UPLOAD DEBUG] No file selected');
      return;
    }

    const file = input.files[0];
    console.log('[UPLOAD DEBUG] File selected:', file.name, 'type:', file.type, 'size:', file.size);

    try {
      console.log('[UPLOAD DEBUG] Starting upload to Home Assistant API');

      // Use the uploadImage utility function to upload the file to Home Assistant
      const { uploadImage } = await import('./utils/image-upload');
      const result = await uploadImage(this.hass, file);

      if (!result.success) {
        throw new Error(result.error || 'Failed to upload image');
      }

      // Check if we have a valid path from the upload
      if (!result.path) {
        console.error('[UPLOAD DEBUG] Error: Upload successful but no path returned');
        throw new Error('Upload successful but no path returned from server');
      }

      console.log('[UPLOAD DEBUG] Upload successful, path:', result.path);

      // Update configuration with the new image path
      // Remove the success alert - no need to notify user on success
      this._updateConfig({
        vehicle_image: result.path,
        vehicle_image_type: 'upload',
      });

      console.log('[UPLOAD DEBUG] Updated config with new image path:', result.path);
    } catch (error) {
      console.error('[UPLOAD DEBUG] Error uploading file:', error);
      // Keep error alert for failures
      alert('Error uploading image: ' + (error instanceof Error ? error.message : String(error)));
    }
  }

  private _formatFieldName(name: string): string {
    return name
      .split('_')
      .map(word => word.charAt(0).toUpperCase() + word.slice(1))
      .join(' ');
  }

  // Add these helper methods inside the class, before the render() method

  private _createDefaultIconRow(): IconRowConfig {
    return {
      id: this._generateUniqueId(),
      width: '100',
      alignment: 'space-between',
      spacing: 'medium',
      icons: [], // Make sure this is an empty array, not undefined
    };
  }

  private _createDefaultIcon(): IconConfig {
    return {
      entity: '',
      icon_inactive: 'mdi:help-circle-outline',
      icon_active: 'mdi:help-circle',
      color_inactive: 'var(--secondary-text-color)',
      color_active: 'var(--primary-color)',
      inactive_state: 'off',
      active_state: 'on',
      show_state: true,
      show_name: false,
      show_units: true,
      name: '',
      on_click_action: 'toggle',
      text_position: 'bottom',
      vertical_alignment: 'center',
      icon_size: 'medium',
      text_size: 'medium',
    };
  }

  private _generateUniqueId(): string {
    return Math.random().toString(36).substring(2, 9);
  }

  private _rearrangeIconRows(fromRowId: string, toRowId: string) {
    const iconRows = [...(this.config.icon_rows || [])];
    const fromIndex = iconRows.findIndex(row => row.id === fromRowId);
    const toIndex = iconRows.findIndex(row => row.id === toRowId);

    if (fromIndex >= 0 && toIndex >= 0) {
      const [movedRow] = iconRows.splice(fromIndex, 1);
      iconRows.splice(toIndex, 0, movedRow);

      this._updateConfig({ icon_rows: iconRows });
    }
  }

  // Add this helper method for creating default crop settings
  private _createDefaultCropSettings(): ImageCropSettings {
    return {
      top: 0,
      right: 0,
      bottom: 0,
      left: 0,
    };
  }

  // Add a method to load the cropperjs library
  private async _loadCropperJS() {
    // Check if cropperjs is already loaded
    if (window.cropperjs) return;

    // Create script element for cropperjs
    const script = document.createElement('script');
    script.src = 'https://cdnjs.cloudflare.com/ajax/libs/cropperjs/1.5.12/cropper.min.js';
    script.async = true;

    // Create link element for cropperjs CSS
    const link = document.createElement('link');
    link.rel = 'stylesheet';
    link.href = 'https://cdnjs.cloudflare.com/ajax/libs/cropperjs/1.5.12/cropper.min.css';

    // Add to document
    document.head.appendChild(script);
    document.head.appendChild(link);

    // Wait for script to load
    await new Promise(resolve => {
      script.onload = resolve;
    });

    // Add cropperjs to window for typechecking purposes
    window.cropperjs = window.Cropper;
  }

  // Add a method to render the image cropper
  private _renderImageCropper() {
    if (!this._cropperActive) return html``;

    return html`
      <div class="cropper-overlay">
        <div class="cropper-container">
          <div class="cropper-header">
            <h3>Crop Image</h3>
            <ha-icon-button
              @click=${() => {
                this._cropperActive = false;
                this._cropperImage = '';
              }}
            >
              <ha-icon icon="mdi:close"></ha-icon>
            </ha-icon-button>
          </div>
          <div class="cropper-body">
            <img
              src="${this._cropperImage}"
              id="crop-image"
              style="max-width: 100%; max-height: 60vh;"
            />
            <div class="cropper-instructions">
              Drag to create a crop area. Double-click to crop.
            </div>
          </div>
          <div class="cropper-footer">
            <ha-button
              @click=${() => {
                this._cropperActive = false;
                this._cropperImage = '';
              }}
            >
              Cancel
            </ha-button>
            <ha-button @click=${this._applyCrop} class="primary"> Apply Crop </ha-button>
          </div>
        </div>
      </div>
    `;
  }

  // Add a method to apply the crop
  private async _applyCrop() {
    // Get the cropper instance
    const cropImage = this.shadowRoot?.getElementById('crop-image');
    if (!cropImage || !window.cropperjs) {
      this._cropperActive = false;
      return;
    }

    const cropper = (cropImage as any).cropper;
    if (!cropper) {
      this._cropperActive = false;
      return;
    }

    try {
      // Get the cropped canvas
      const canvas = cropper.getCroppedCanvas({
        minWidth: 256,
        minHeight: 256,
        maxWidth: 4096,
        maxHeight: 4096,
        fillColor: '#fff',
        imageSmoothingEnabled: true,
        imageSmoothingQuality: 'high',
      });

      // Convert canvas to blob instead of base64
      const blob = await new Promise<Blob>((resolve, reject) => {
        canvas.toBlob(blob => {
          if (blob) {
            resolve(blob);
          } else {
            reject(new Error('Failed to convert canvas to blob'));
          }
        }, 'image/png');
      });

      // Create a file object from the blob
      const filename = `cropped_image_${Date.now()}.png`;
      const file = new File([blob], filename, { type: 'image/png' });

      // Upload to Home Assistant
      const { uploadImage } = await import('./utils/image-upload');
      const result = await uploadImage(this.hass, file);

      if (!result.success) {
        throw new Error(result.error || 'Failed to upload cropped image');
      }

      // Update the config based on the target field
      if (this._cropperTargetField === 'vehicle_image') {
        this._updateConfig({ vehicle_image: result.path });
      } else if (this._cropperTargetField.startsWith('action_image_')) {
        // Handle action image update
        const [_, entity, state] = this._cropperTargetField.split('_');

        // Create a deep copy of the config
        const newConfig = JSON.parse(JSON.stringify(this.config));

        // Initialize action_images if needed
        if (!newConfig.action_images) {
          newConfig.action_images = {};
        }

        // Initialize entity entry if needed
        if (!newConfig.action_images[entity]) {
          newConfig.action_images[entity] = {};
        }

        // Set the image path from upload
        newConfig.action_images[entity][state] = result.path;

        // Update the config
        this._updateConfig(newConfig);
      }
    } catch (error) {
      console.error('[CROP UPLOAD DEBUG] Error uploading cropped image:', error);
      alert('Failed to upload cropped image. Please try again.');
    } finally {
      // Reset the cropper state
      this._cropperActive = false;
      this._cropperImage = '';
    }
  }

  // Initialize cropper when the image is loaded
  updated(changedProperties) {
    super.updated(changedProperties);

    // Initialize the cropper when the cropper becomes active
    if (changedProperties.has('_cropperActive') && this._cropperActive) {
      setTimeout(() => {
        const cropImage = this.shadowRoot?.getElementById('crop-image');
        if (!cropImage || !window.cropperjs) return;

        new window.cropperjs(cropImage, {
          aspectRatio: NaN, // Free aspect ratio
          viewMode: 1,
          dragMode: 'crop',
          autoCrop: true,
          background: true,
          modal: true,
          guides: true,
          highlight: true,
          cropBoxMovable: true,
          cropBoxResizable: true,
          toggleDragModeOnDblclick: true,
        });
      }, 100);
    }
  }

  private _renderCropSliders(cropProperty: string) {
    // Get current crop settings or use defaults
    const cropSettings = this.config[cropProperty] || this._createDefaultCropSettings();

    return html`
      <div class="crop-input-row">
        <div class="crop-input-field">
          <span class="crop-label">Top</span>
          <ha-textfield
            type="number"
            .value=${cropSettings.top || 0}
            @change=${e =>
              this._updateImageCrop(cropProperty, 'top', parseInt(e.target.value) || 0)}
          ></ha-textfield>
          <span class="crop-unit">px</span>
        </div>

        <div class="crop-input-field">
          <span class="crop-label">Right</span>
          <ha-textfield
            type="number"
            .value=${cropSettings.right || 0}
            @change=${e =>
              this._updateImageCrop(cropProperty, 'right', parseInt(e.target.value) || 0)}
          ></ha-textfield>
          <span class="crop-unit">px</span>
        </div>

        <div class="crop-input-field">
          <span class="crop-label">Bottom</span>
          <ha-textfield
            type="number"
            .value=${cropSettings.bottom || 0}
            @change=${e =>
              this._updateImageCrop(cropProperty, 'bottom', parseInt(e.target.value) || 0)}
          ></ha-textfield>
          <span class="crop-unit">px</span>
        </div>

        <div class="crop-input-field">
          <span class="crop-label">Left</span>
          <ha-textfield
            type="number"
            .value=${cropSettings.left || 0}
            @change=${e =>
              this._updateImageCrop(cropProperty, 'left', parseInt(e.target.value) || 0)}
          ></ha-textfield>
          <span class="crop-unit">px</span>
        </div>
      </div>

      <div class="crop-explanation">
        <ha-icon icon="mdi:information-outline"></ha-icon>
        <span>Enter pixel values (positive or negative) to adjust cropping and padding</span>
      </div>
    `;
  }

  private _renderIconRows() {
    const { icon_rows = [] } = this.config;

    if (!icon_rows || icon_rows.length === 0) return html``;

    return html`
      <div class="icon-rows-container">${icon_rows.map(row => this._renderCardIconRow(row))}</div>
    `;
  }

  private _renderCardIconRow(row: IconRowConfig) {
    if (!row.icons || !row.icons.length) return html``;

    const width = row.width || '100';
    const alignment = row.alignment || 'space-between';
    const spacing = row.spacing || 'medium';

    const spacingValue =
      {
        none: '0',
        small: '8px',
        medium: '16px',
        large: '24px',
      }[spacing] || '16px';

    return html`
      <div
        class="icon-row"
        style="width: ${width}%; justify-content: ${alignment}; gap: ${spacingValue};"
      >
        ${row.icons.map(icon => this._renderCardIcon(icon))}
      </div>
    `;
  }

  private _renderCardIcon(icon: IconConfig) {
    if (!icon.entity) return html``;

    const state = this.hass.states[icon.entity];
    if (!state) return html``;

    const isActive = state.state !== icon.inactive_state;
    const displayIcon = isActive && icon.icon_active ? icon.icon_active : icon.icon_inactive;
    const displayColor = isActive && icon.color_active ? icon.color_active : icon.color_inactive;

    // Use name if provided, otherwise use friendly name from entity
    const displayName = icon.name || state.attributes.friendly_name || '';

    // Get original state
    let displayState = state.state;
    const unit = state.attributes.unit_of_measurement;

    // Format state if formatted_entities is enabled
    if (this.config.formatted_entities && displayState) {
      // Handle numeric values with proper formatting
      if (!isNaN(Number(displayState))) {
        const numValue = Number(displayState);

        // If it's a large integer or has many decimal places, format it appropriately
        if (Math.abs(numValue) >= 1000 || numValue % 1 !== 0) {
          // Format large numbers with commas and limit decimal places
          displayState = numValue.toLocaleString('en-US', {
            maximumFractionDigits: 2,
            minimumFractionDigits: 0,
          });
        }
      } else {
        // For non-numeric values, capitalize and replace underscores
        displayState = displayState
          .replace(/_/g, ' ')
          .replace(/\b\w/g, match => match.toUpperCase());
      }
    }

    // Add unit of measurement, currency, or other formatting from attributes
    if (displayState && icon.show_state) {
      const prefix = state.attributes.prefix || '';
      const suffix = state.attributes.suffix || '';

      // Show units if enabled
      if (unit && icon.show_units) {
        displayState = `${displayState} ${unit}`;
      }

      // Apply any prefix/suffix if they exist
      displayState = `${prefix}${displayState}${suffix}`;
    }

    // Set icon size based on configuration
    const iconSize = {
      small: '20px',
      medium: '24px',
      large: '32px',
    }[icon.icon_size || 'medium'];

    // Set text size based on configuration
    const textSize = {
      small: '0.8em',
      medium: '0.9em',
      large: '1.1em',
    }[icon.text_size || 'medium'];

    // Set flex direction based on text position
    const flexDirection = {
      bottom: 'column',
      top: 'column-reverse',
      left: 'row-reverse',
      right: 'row',
    }[icon.text_position || 'bottom'];

    // Apply vertical alignment
    const alignItems = icon.vertical_alignment || 'center';

    return html`
      <div
        class="icon-container"
        @click=${() => this._handleIconClick(icon)}
        style="flex-direction: ${flexDirection}; align-items: ${alignItems};"
      >
        <ha-icon
          .icon="${displayIcon || 'mdi:help-circle-outline'}"
          style="color: ${displayColor || 'var(--primary-text-color)'}; font-size: ${iconSize};"
        ></ha-icon>
        <div
          style="display: flex; flex-direction: column; align-items: center; font-size: ${textSize};"
        >
          ${icon.show_name ? html`<div class="icon-label">${displayName}</div>` : ''}
          ${icon.show_state ? html`<div class="icon-state">${displayState}</div>` : ''}
        </div>
      </div>
    `;
  }

  private _handleIconClick(icon: IconConfig) {
    if (!icon.entity || !icon.on_click_action) return;

    switch (icon.on_click_action) {
      case 'toggle':
        const domain = icon.entity.split('.')[0];
        this.hass.callService(domain, 'toggle', { entity_id: icon.entity });
        break;
      case 'more-info':
        const event = new CustomEvent('hass-more-info', {
          detail: { entityId: icon.entity },
          bubbles: true,
          composed: true,
        });
        this.dispatchEvent(event);
        break;
      // Add more actions if needed
    }
  }

  // Add this to your _renderVehicleImageConfig and _renderActionImageConfig methods

  private _renderVehicleImageConfig() {
    // ... existing code ...

    return html`
      <div class="section">
        <div class="section-header">
          <div class="section-title">Vehicle Image</div>
        </div>
        <div class="section-content">
          <!-- Existing image type selector and controls -->

          <!-- Add crop accordion -->
          <ha-expansion-panel .header=${'Image Crop Settings'} outlined>
            <div class="crop-controls">
              <div class="crop-sliders">
                <div class="crop-slider">
                  <span class="crop-label">Top</span>
                  <ha-slider
                    min="0"
                    max="50"
                    step="1"
                    .value=${this.config.vehicle_image_crop?.top || 0}
                    @change=${e =>
                      this._updateImageCrop('vehicle_image_crop', 'top', e.target.value)}
                  ></ha-slider>
                  <span class="crop-value">${this.config.vehicle_image_crop?.top || 0}%</span>
                </div>

                <div class="crop-slider">
                  <span class="crop-label">Right</span>
                  <ha-slider
                    min="0"
                    max="50"
                    step="1"
                    .value=${this.config.vehicle_image_crop?.right || 0}
                    @change=${e =>
                      this._updateImageCrop('vehicle_image_crop', 'right', e.target.value)}
                  ></ha-slider>
                  <span class="crop-value">${this.config.vehicle_image_crop?.right || 0}%</span>
                </div>

                <div class="crop-slider">
                  <span class="crop-label">Bottom</span>
                  <ha-slider
                    min="0"
                    max="50"
                    step="1"
                    .value=${this.config.vehicle_image_crop?.bottom || 0}
                    @change=${e =>
                      this._updateImageCrop('vehicle_image_crop', 'bottom', e.target.value)}
                  ></ha-slider>
                  <span class="crop-value">${this.config.vehicle_image_crop?.bottom || 0}%</span>
                </div>

                <div class="crop-slider">
                  <span class="crop-label">Left</span>
                  <ha-slider
                    min="0"
                    max="50"
                    step="1"
                    .value=${this.config.vehicle_image_crop?.left || 0}
                    @change=${e =>
                      this._updateImageCrop('vehicle_image_crop', 'left', e.target.value)}
                  ></ha-slider>
                  <span class="crop-value">${this.config.vehicle_image_crop?.left || 0}%</span>
                </div>
              </div>

              <div class="crop-explanation">
                <ha-icon icon="mdi:information-outline"></ha-icon>
                <span>Move sliders to the right to remove more of the image from that side</span>
              </div>
            </div>
          </ha-expansion-panel>
        </div>
      </div>
    `;
  }

  // Do the same for the Action Image config
  private _renderActionImageConfig() {
    // ... existing code ...
    // Add the same accordion with similar sliders for action image
    // Just change the method names and config properties
  }

  // Add these helper methods
  private _updateImageCrop(cropProperty: string, side: string, value: number) {
    const currentCrop = this.config[cropProperty] || { top: 0, right: 0, bottom: 0, left: 0 };
    const updatedCrop = { ...currentCrop, [side]: value };

    const newConfig = {
      ...this.config,
      [cropProperty]: updatedCrop,
    };

    this._updateConfig(newConfig);
  }

  private _resetImageCrop(cropProperty: string) {
    const newConfig = {
      ...this.config,
      [cropProperty]: { top: 0, right: 0, bottom: 0, left: 0 },
    };

    this._updateConfig(newConfig);
  }

  // Add drag and drop methods for bars
  private _handleBarDragStart(e, index) {
    this._draggedBar = index;
    e.dataTransfer.effectAllowed = 'move';
    // Use a transparent image as drag "ghost"
    const dragImage = document.createElement('div');
    dragImage.textContent = 'Bar ' + (index + 1);
    dragImage.style.position = 'absolute';
    dragImage.style.top = '-1000px';
    document.body.appendChild(dragImage);
    e.dataTransfer.setDragImage(dragImage, 0, 0);
    setTimeout(() => {
      document.body.removeChild(dragImage);
    }, 0);
  }

  private _handleBarDragEnd() {
    this._draggedBar = null;
    this._dropTargetBar = null;
  }

  private _handleBarDragOver(e, index) {
    e.preventDefault();
    e.dataTransfer.dropEffect = 'move';
    if (this._draggedBar !== null && this._draggedBar !== index) {
      this._dropTargetBar = index;
    }
  }

  private _handleBarDragLeave() {
    this._dropTargetBar = null;
  }

  private _handleBarDrop(e, index) {
    e.preventDefault();
    if (this._draggedBar === null || this._draggedBar === index) {
      return;
    }

    // Reorder bars
    const bars = [...(this.config.bars || [])];
    const [movedBar] = bars.splice(this._draggedBar, 1);
    bars.splice(index, 0, movedBar);

    this._updateConfig({
      ...this.config,
      bars,
    });

    this._draggedBar = null;
    this._dropTargetBar = null;
  }

  // Add this helper method
  private _resetIconColor(rowId: string, iconIndex: number, type: 'active' | 'inactive') {
    const defaultColors = {
      active: 'var(--primary-color)',
      inactive: 'var(--secondary-text-color)',
    };

    const updateProperty = type === 'active' ? 'color_active' : 'color_inactive';
    const updateValue = defaultColors[type];

    this._updateIconConfig(rowId, iconIndex, { [updateProperty]: updateValue });
  }

  // Add this new method to render draggable sections
  private _renderDraggableSections() {
    // Default section order if not set
    const defaultSections = ['title', 'image', 'info', 'bars', 'icons'];
    const sections = this.config.sections_order || defaultSections;
    const layoutType = this.config.layout_type || 'single';

    // If layout is double but sections_columns is not defined, initialize it
    if (layoutType === 'double' && !this.config.sections_columns) {
      // Initialize with all sections in the left column by default
      const initialColumns = {};
      sections.forEach(section => {
        initialColumns[section] = 'left';
      });
      this._updateConfig({ sections_columns: initialColumns });
    }

    // Get column assignments for sections or default to left
    const columns = this.config.sections_columns || {};

    if (layoutType === 'double') {
      // For two-column layout, split sections into left and right columns
      const leftSections = sections.filter(section => columns[section] !== 'right');
      const rightSections = sections.filter(section => columns[section] === 'right');

      return html`
        <div class="draggable-sections-container">
          <div class="columns-wrapper" style="display: flex; flex-direction: column; gap: 24px;">
            <div
              class="column-container left-column"
              @dragover=${(e: DragEvent) => {
                e.preventDefault();
                e.stopPropagation();
                this._handleColumnDragOver(e, 'left');
              }}
              @drop=${(e: DragEvent) => {
                e.preventDefault();
                e.stopPropagation();
                this._handleSectionDrop(e, 'left');
              }}
              @dragenter=${(e: DragEvent) => {
                e.preventDefault();
                e.stopPropagation();
                const container = e.currentTarget as HTMLElement;
                container.classList.add('column-drag-over');
              }}
              @dragleave=${(e: DragEvent) => {
                e.stopPropagation();
                const container = e.currentTarget as HTMLElement;
                const rect = container.getBoundingClientRect();
                // Only remove if we actually leave the container (not just enter a child)
                if (
                  e.clientX < rect.left ||
                  e.clientX > rect.right ||
                  e.clientY < rect.top ||
                  e.clientY > rect.bottom
                ) {
                  container.classList.remove('column-drag-over');
                }
              }}
            >
              <div class="column-header">Left Column</div>
              ${leftSections.map((section, index) =>
                this._renderDraggableSection(section, index, 'left')
              )}
              ${leftSections.length === 0
                ? html`<div class="empty-column-message">Drag sections here</div>`
                : ''}
            </div>
            <div
              class="column-container right-column"
              @dragover=${(e: DragEvent) => {
                e.preventDefault();
                e.stopPropagation();
                this._handleColumnDragOver(e, 'right');
              }}
              @drop=${(e: DragEvent) => {
                e.preventDefault();
                e.stopPropagation();
                this._handleSectionDrop(e, 'right');
              }}
              @dragenter=${(e: DragEvent) => {
                e.preventDefault();
                e.stopPropagation();
                const container = e.currentTarget as HTMLElement;
                container.classList.add('column-drag-over');
              }}
              @dragleave=${(e: DragEvent) => {
                e.stopPropagation();
                const container = e.currentTarget as HTMLElement;
                const rect = container.getBoundingClientRect();
                if (
                  e.clientX < rect.left ||
                  e.clientX > rect.right ||
                  e.clientY < rect.top ||
                  e.clientY > rect.bottom
                ) {
                  container.classList.remove('column-drag-over');
                }
              }}
            >
              <div class="column-header">Right Column</div>
              ${rightSections.map((section, index) =>
                this._renderDraggableSection(section, index, 'right')
              )}
              ${rightSections.length === 0
                ? html`<div class="empty-column-message">Drag sections here</div>`
                : ''}
            </div>
          </div>
        </div>
      `;
    } else {
      // For single column layout, use the original rendering
      return html`
        <div class="draggable-sections-container">
          <div
            class="draggable-sections single-column"
            @dragover=${e => this._handleSectionDragOver(e)}
            @drop=${e => this._handleSectionDrop(e)}
          >
            ${sections.map((section, index) => this._renderDraggableSection(section, index))}
          </div>
        </div>
      `;
    }
  }

  private _handleColumnDragOver(e: DragEvent, targetColumn: string) {
    e.preventDefault();
    e.stopPropagation();

    if (e.dataTransfer) {
      e.dataTransfer.dropEffect = 'move';
    }

    // Highlight the column container
    const container = e.currentTarget as HTMLElement;

    // Add highlight class to the column
    const allColumns = this.shadowRoot?.querySelectorAll('.column-container');
    if (allColumns) {
      [...allColumns].forEach(col => col.classList.remove('column-drag-over'));
      container.classList.add('column-drag-over');
    }

    console.log('Dragging over column:', targetColumn);
  }

  private _renderDraggableSection(section: string, index: number, column: string | null = null) {
    // Check if this is a bar or icon row section
    if (section.startsWith('bar_')) {
      const barId = section.substring(4); // Remove 'bar_' prefix
      const barIndex = parseInt(barId);
      const bar = this.config.bars?.[barIndex];

      if (bar) {
        // Get entity display name for the header
        const entityName = this._getFriendlyName(bar.entity);
        const displayName = this._truncateText(entityName, 20) || 'Bar ' + (barIndex + 1);

        // Check if this section is hidden
        const isHidden = this.config.hidden_sections?.includes(section);

        return html`
          <div
            class="draggable-section"
            draggable="true"
            @dragstart=${(e: DragEvent) => this._handleSectionDragStart(e, index, column)}
            @dragend=${this._handleSectionDragEnd}
            data-index="${index}"
            data-section="${section}"
            data-column="${column || ''}"
          >
            <div class="drag-handle">
              <ha-icon icon="mdi:drag"></ha-icon>
            </div>
            <div class="section-info" style="flex: 1; overflow: hidden;">
              <ha-icon
                icon="mdi:chart-bar"
                style="font-size: 20px; color: var(--primary-color);"
              ></ha-icon>
              <span
                style="font-weight: 500; overflow: hidden; text-overflow: ellipsis; white-space: nowrap; flex: 1;"
                >Bar: ${displayName}</span
              >
            </div>
            <div
              style="margin-left: auto; cursor: pointer;"
              @click=${(e: MouseEvent) => this._toggleSectionVisibility(e, section)}
            >
              <ha-icon icon="${isHidden ? 'mdi:eye-off' : 'mdi:eye'}"></ha-icon>
            </div>
          </div>
        `;
      }
    } else if (section.startsWith('icon_row_')) {
      const rowId = section.substring(9); // Remove 'icon_row_' prefix
      const row = this.config.icon_rows?.find(r => r.id === rowId);

      if (row) {
        // Get a summary of the icons in this row
        const iconCount = row.icons?.length || 0;
        const displayName = `Icon Row (${iconCount} icon${iconCount !== 1 ? 's' : ''})`;

        // Check if this section is hidden
        const isHidden = this.config.hidden_sections?.includes(section);

        return html`
          <div
            class="draggable-section"
            draggable="true"
            @dragstart=${(e: DragEvent) => this._handleSectionDragStart(e, index, column)}
            @dragend=${this._handleSectionDragEnd}
            data-index="${index}"
            data-section="${section}"
            data-column="${column || ''}"
          >
            <div class="drag-handle">
              <ha-icon icon="mdi:drag"></ha-icon>
            </div>
            <div class="section-info" style="flex: 1; overflow: hidden;">
              <ha-icon
                icon="mdi:view-grid"
                style="font-size: 20px; color: var(--primary-color);"
              ></ha-icon>
              <span
                style="font-weight: 500; overflow: hidden; text-overflow: ellipsis; white-space: nowrap; flex: 1;"
                >${displayName}</span
              >
            </div>
            <div
              style="margin-left: auto; cursor: pointer;"
              @click=${(e: MouseEvent) => this._toggleSectionVisibility(e, section)}
            >
              <ha-icon icon="${isHidden ? 'mdi:eye-off' : 'mdi:eye'}"></ha-icon>
            </div>
          </div>
        `;
      }
    }

    // If not a special section, use the default rendering
    const sectionInfo = {
      title: { name: 'Title', icon: 'mdi:format-title' },
      image: { name: 'Vehicle Image', icon: 'mdi:car' },
      info: { name: 'Vehicle Info', icon: 'mdi:information-outline' },
    };

    const info = sectionInfo[section] || { name: section, icon: 'mdi:help-circle' };

    // Check if this section is hidden
    const isHidden = this.config.hidden_sections?.includes(section);

    return html`
      <div
        class="draggable-section"
        draggable="true"
        @dragstart=${(e: DragEvent) => this._handleSectionDragStart(e, index, column)}
        @dragend=${this._handleSectionDragEnd}
        data-index="${index}"
        data-section="${section}"
        data-column="${column || ''}"
      >
        <div class="drag-handle">
          <ha-icon icon="mdi:drag"></ha-icon>
        </div>
        <div class="section-info" style="flex: 1; overflow: hidden;">
          <ha-icon
            icon="${info.icon}"
            style="font-size: 20px; color: var(--primary-color);"
          ></ha-icon>
          <span
            style="font-weight: 500; overflow: hidden; text-overflow: ellipsis; white-space: nowrap; flex: 1;"
            >${info.name}</span
          >
        </div>
        <div
          style="margin-left: auto; cursor: pointer;"
          @click=${(e: MouseEvent) => this._toggleSectionVisibility(e, section)}
        >
          <ha-icon icon="${isHidden ? 'mdi:eye-off' : 'mdi:eye'}"></ha-icon>
        </div>
      </div>
    `;
  }

  // Add a method to toggle section visibility
  private _toggleSectionVisibility(e: MouseEvent, section: string) {
    e.preventDefault();
    e.stopPropagation();

    // Create a copy of the hidden_sections array or initialize if it doesn't exist
    const hiddenSections = [...(this.config.hidden_sections || [])];

    // Toggle the section's visibility
    const sectionIndex = hiddenSections.indexOf(section);
    if (sectionIndex === -1) {
      // Section is currently visible, hide it
      hiddenSections.push(section);
    } else {
      // Section is currently hidden, show it
      hiddenSections.splice(sectionIndex, 1);
    }

    // Update the config
    this._updateConfig({ hidden_sections: hiddenSections });
  }

  // Drag and drop handlers
  private _handleSectionDragStart(e: DragEvent, index: number, column: string | null = null) {
    // Store both the index and column of the dragged section
    this._draggedSection = index;
    // Store the column and section data directly on the dataTransfer object
    const sectionElement = e.currentTarget as HTMLElement;
    const sectionName = sectionElement.getAttribute('data-section');

    if (e.dataTransfer) {
      e.dataTransfer.effectAllowed = 'move';
      e.dataTransfer.setData('text/plain', index.toString());
      if (sectionName) {
        e.dataTransfer.setData('application/section-name', sectionName);
      }
      e.dataTransfer.setData('application/section-column', column || '');

      // Create a better ghost image for dragging
      const rect = sectionElement.getBoundingClientRect();
      const ghostEl = sectionElement.cloneNode(true) as HTMLElement;

      // Style the ghost element to look like the original
      ghostEl.style.width = `${rect.width}px`;
      ghostEl.style.opacity = '0.9';
      ghostEl.style.position = 'absolute';
      ghostEl.style.top = '-1000px';
      ghostEl.style.zIndex = '9999';
      ghostEl.style.pointerEvents = 'none';
      ghostEl.style.boxShadow = '0 5px 10px rgba(0, 0, 0, 0.2)';
      ghostEl.style.transform = 'rotate(2deg)';

      // Keep exact styles from the original
      ghostEl.style.backgroundColor = window.getComputedStyle(sectionElement).backgroundColor;
      ghostEl.style.color = window.getComputedStyle(sectionElement).color;
      ghostEl.style.padding = window.getComputedStyle(sectionElement).padding;
      ghostEl.style.borderRadius = window.getComputedStyle(sectionElement).borderRadius;
      ghostEl.style.fontWeight = window.getComputedStyle(sectionElement).fontWeight;

      // Add ghost to document body
      document.body.appendChild(ghostEl);

      // Set the drag image with appropriate offset
      e.dataTransfer.setDragImage(ghostEl, 20, 20);

      // Clean up ghost element after a short delay
      setTimeout(() => {
        if (document.body.contains(ghostEl)) {
          document.body.removeChild(ghostEl);
        }
      }, 300);

      console.log('Drag started for section:', sectionName, 'from column:', column || 'single');
    }

    if (e.currentTarget && e.currentTarget instanceof HTMLElement) {
      e.currentTarget.classList.add('dragging');
    }
  }

  private _handleSectionDragEnd(e: DragEvent) {
    if (e.currentTarget && e.currentTarget instanceof HTMLElement) {
      e.currentTarget.classList.remove('dragging');
    }
    this._draggedSection = null;
  }

  private _handleSectionDragOver(e: DragEvent, targetColumn: string | null = null) {
    e.preventDefault();
    if (e.dataTransfer) {
      e.dataTransfer.dropEffect = 'move';
    }

    // In single column layout, use the original target finding logic
    if (!targetColumn) {
      const target = this._findDraggableSectionParent(e.target as HTMLElement);
      if (!target) return;

      const targetIndex = parseInt(target.getAttribute('data-index') || '0');

      if (this._draggedSection !== null && this._draggedSection !== targetIndex) {
        // Highlight drop zone
        const sections = this.shadowRoot?.querySelectorAll('.draggable-section');
        if (sections) {
          [...sections].forEach(s => s.classList.remove('drag-over'));
          target.classList.add('drag-over');
        }
      }
    } else {
      // For two-column layout, highlight the column
      const columnContainer = e.currentTarget as HTMLElement;

      // Highlight the column as a drop target
      const allColumns = this.shadowRoot?.querySelectorAll('.column-container');
      if (allColumns) {
        [...allColumns].forEach(col => col.classList.remove('column-drag-over'));
        columnContainer.classList.add('column-drag-over');
      }
    }
  }

  private _handleSectionDrop(e: DragEvent, targetColumn: string | null = null) {
    e.preventDefault();

    // Get the section that is being moved
    if (!e.dataTransfer) return;

    const sectionName = e.dataTransfer.getData('application/section-name');
    const sourceColumn = e.dataTransfer.getData('application/section-column');

    console.log(
      'Dropping section:',
      sectionName,
      'from column:',
      sourceColumn,
      'to column:',
      targetColumn
    );

    if (this.config.layout_type === 'double' && targetColumn) {
      // Handle drop in two-column layout
      // Update the column assignment
      if (!sectionName) {
        console.error('No section name found in dataTransfer');
        return;
      }

      const columns = { ...(this.config.sections_columns || {}) };

      // Make sure we're getting a valid target column
      if (targetColumn !== 'left' && targetColumn !== 'right') {
        console.error('Invalid target column:', targetColumn);
        return;
      }

      // Update the section's column
      columns[sectionName] = targetColumn as 'left' | 'right';

      // Get updated config with deep copy to avoid reference issues
      const newConfig = JSON.parse(JSON.stringify(this.config));
      newConfig.sections_columns = columns;

      // Apply the update
      this._updateConfig(newConfig);
      console.log('Updated columns config:', columns);
    } else {
      // Handle drop in single-column layout (original behavior)
      const target = this._findDraggableSectionParent(e.target as HTMLElement);
      if (!target) return;

      const targetIndex = parseInt(target.getAttribute('data-index') || '0');

      if (this._draggedSection !== null && this._draggedSection !== targetIndex) {
        // Create a copy of the sections array instead of modifying it directly
        const sections = [
          ...(this.config.sections_order || ['title', 'image', 'info', 'bars', 'icons']),
        ];

        // Perform the reordering on the copy
        const movedSection = sections[this._draggedSection];
        const newSections = sections.filter((_, i) => i !== this._draggedSection);
        newSections.splice(targetIndex, 0, movedSection);

        console.log('Reordering sections:', {
          from: this._draggedSection,
          to: targetIndex,
          sections,
          newSections,
        });

        // Update config with the new array
        this._updateConfig({ sections_order: newSections });
      }
    }

    // Clear highlighting
    const sectionElements = this.shadowRoot?.querySelectorAll('.draggable-section');
    if (sectionElements) {
      [...sectionElements].forEach(s => s.classList.remove('drag-over'));
    }

    const columnElements = this.shadowRoot?.querySelectorAll('.column-container');
    if (columnElements) {
      [...columnElements].forEach(col => col.classList.remove('column-drag-over'));
    }

    // Force UI update
    this.requestUpdate();
  }

  private _findDraggableSectionParent(element: HTMLElement): HTMLElement | null {
    let el: HTMLElement | null = element;
    while (el && !el.classList.contains('draggable-section')) {
      el = el.parentElement;
    }
    return el;
  }

  private _renderGradientEditor(bar: BarConfig, index: number) {
    if (!bar.use_gradient) {
      return html``;
    }

    // Ensure gradient_stops exists
    const gradientStops = bar.gradient_stops || [
      { id: 'stop1', position: 0, color: '#ff0000' },
      { id: 'stop2', position: 50, color: '#ffff00' },
      { id: 'stop3', position: 100, color: '#00ff00' },
    ];

    // Sort stops by position
    const sortedStops = [...gradientStops].sort((a, b) => a.position - b.position);

    // Generate gradient preview
    const gradientString = `linear-gradient(to right, 
      ${sortedStops[0].color} 0%, 
      ${sortedStops
        .map((stop, i) => {
          // For all except first and last, use the actual position
          if (i > 0 && i < sortedStops.length - 1) {
            return `${stop.color} ${stop.position}%`;
          }
          return '';
        })
        .filter(Boolean)
        .join(', ')},
      ${sortedStops[sortedStops.length - 1].color} 100%
    )`;

    return html`
      <div class="gradient-editor-section" @click=${e => e.stopPropagation()}>
        <div class="section-header gradient-header">
          <span>Gradient Editor</span>
          <ha-icon-button
            .path=${'M19,13H13V19H11V13H5V11H11V5H13V11H19V13Z'}
            @mousedown=${e => {
              e.stopPropagation();
              e.preventDefault();
            }}
            @click=${e => {
              e.stopPropagation();
              e.preventDefault();
              this._addGradientStop(index);
            }}
            .title=${'Add Gradient Stop'}
            class="add-button"
          ></ha-icon-button>
        </div>
        <div class="description">
          Create a smooth color transition for the bar. The bar will use the color at the position
          that matches the current percentage value.
        </div>
        <div class="gradient-preview" style="background: ${gradientString};"></div>

        <div class="gradient-stops-container">
          ${sortedStops.map(
            stop => html`
              <div
                class="gradient-stop-row"
                draggable="true"
                @dragstart=${e => this._handleStopDragStart(e, index, stop.id)}
                @dragend=${e => {
                  e.stopPropagation();
                  e.preventDefault();
                  this._handleStopDragEnd();
                }}
                @dragover=${e => {
                  e.stopPropagation();
                  e.preventDefault();
                  this._handleStopDragOver(e, index, stop.id);
                }}
                @drop=${e => {
                  e.stopPropagation();
                  e.preventDefault();
                  this._handleStopDrop(e, index, stop.id);
                }}
              >
                <ha-icon class="drag-handle" .icon=${'mdi:drag-horizontal-variant'}></ha-icon>
                <colorpicker-wc
                  class="gradient-color-picker"
                  color="${stop.color}"
                  @color-changed=${e => {
                    e.stopPropagation();
                    this._updateGradientStopColor(index, stop.id, e.detail.value);
                  }}
                ></colorpicker-wc>
                <div class="gradient-slider-container">
                  <ha-slider
                    min="0"
                    max="100"
                    .value=${stop.position}
                    @change=${e => {
                      e.stopPropagation();
                      const value = parseInt(e.target.value);
                      this._updateGradientStopPosition(index, stop.id, value);
                    }}
                    @click=${e => e.stopPropagation()}
                  ></ha-slider>
                </div>
                <span class="position-label">${stop.position}%</span>
                ${sortedStops.length > 2
                  ? html`
                      <ha-icon-button
                        .path=${ICON_PATH_DELETE}
                        @click=${e => {
                          e.stopPropagation();
                          e.preventDefault();
                          this._removeGradientStop(index, stop.id);
                        }}
                        .title=${'Remove Stop'}
                        class="remove-button"
                      ></ha-icon-button>
                    `
                  : html``}
              </div>
            `
          )}
        </div>
      </div>
    `;
  }

  // Add methods for gradient stop management
  private _addGradientStop(barIndex: number) {
    // Create a deep copy of the config first
    const newConfig = JSON.parse(JSON.stringify(this.config));

    if (!newConfig.bars || !newConfig.bars[barIndex]) return;

    // Ensure gradient_stops exists
    if (!newConfig.bars[barIndex].gradient_stops) {
      newConfig.bars[barIndex].gradient_stops = [];
    }

    const stops = newConfig.bars[barIndex].gradient_stops;

    // Create a new stop with position in the middle of largest gap
    if (stops.length === 0) {
      // If no stops, create default ones
      stops.push(
        { id: this._generateUniqueId(), position: 0, color: '#ff0000' },
        { id: this._generateUniqueId(), position: 100, color: '#00ff00' }
      );
    } else {
      // Sort stops by position
      const sortedStops = [...stops].sort((a, b) => a.position - b.position);

      // Find largest gap
      let maxGap = 0;
      let gapPosition = 50;

      for (let i = 0; i < sortedStops.length - 1; i++) {
        const gap = sortedStops[i + 1].position - sortedStops[i].position;
        if (gap > maxGap) {
          maxGap = gap;
          gapPosition = sortedStops[i].position + gap / 2;
        }
      }

      // Add new stop in the middle of largest gap
      stops.push({
        id: this._generateUniqueId(),
        position: Math.round(gapPosition),
        color: '#ffff00', // Default to yellow for new stops
      });
    }

    // Make sure use_gradient stays on
    newConfig.bars[barIndex].use_gradient = true;

    // Update config
    this._updateConfig(newConfig);

    // Force immediate update of UI
    this.requestUpdate();
  }

  private _removeGradientStop(barIndex: number, stopId: string) {
    // Create a deep copy of the config first
    const newConfig = JSON.parse(JSON.stringify(this.config));

    if (!newConfig.bars || !newConfig.bars[barIndex] || !newConfig.bars[barIndex].gradient_stops)
      return;

    // Don't allow fewer than 2 stops
    if (newConfig.bars[barIndex].gradient_stops.length <= 2) return;

    // Filter out the stop to remove
    newConfig.bars[barIndex].gradient_stops = newConfig.bars[barIndex].gradient_stops.filter(
      stop => stop.id !== stopId
    );

    // Make sure use_gradient stays on
    newConfig.bars[barIndex].use_gradient = true;

    // Update config
    this._updateConfig(newConfig);

    // Force immediate update of UI
    this.requestUpdate();
  }

  private _updateGradientStopPosition(barIndex: number, stopId: string, position: number) {
    // Create a deep copy of the config first
    const newConfig = JSON.parse(JSON.stringify(this.config));

    if (!newConfig.bars || !newConfig.bars[barIndex] || !newConfig.bars[barIndex].gradient_stops)
      return;

    // Update position for the specific stop
    newConfig.bars[barIndex].gradient_stops = newConfig.bars[barIndex].gradient_stops.map(stop =>
      stop.id === stopId ? { ...stop, position } : stop
    );

    // Make sure use_gradient stays on
    newConfig.bars[barIndex].use_gradient = true;

    // Update config
    this._updateConfig(newConfig);

    // Force immediate update of UI
    this.requestUpdate();
  }

  private _updateGradientStopColor(barIndex: number, stopId: string, color: string) {
    // Create a deep copy of the config first
    const newConfig = JSON.parse(JSON.stringify(this.config));

    if (!newConfig.bars || !newConfig.bars[barIndex] || !newConfig.bars[barIndex].gradient_stops)
      return;

    // Update color for the specific stop
    newConfig.bars[barIndex].gradient_stops = newConfig.bars[barIndex].gradient_stops.map(stop =>
      stop.id === stopId ? { ...stop, color } : stop
    );

    // Make sure use_gradient stays on
    newConfig.bars[barIndex].use_gradient = true;

    // Update config
    this._updateConfig(newConfig);

    // Force immediate update of UI
    this.requestUpdate();
  }

  // Drag and drop handlers for gradient stops
  private _handleStopDragStart(e: DragEvent, barIndex: number, stopId: string) {
    e.dataTransfer!.setData('application/json', JSON.stringify({ barIndex, stopId }));
    e.dataTransfer!.effectAllowed = 'move';
  }

  private _handleStopDragEnd() {
    // Clean up drag state if needed
  }

  private _handleStopDragOver(e: DragEvent, barIndex: number, stopId: string) {
    e.preventDefault();
    e.dataTransfer!.dropEffect = 'move';

    // Use the parameters to avoid TypeScript warning
    console.log(`Dragging over stop ${stopId} in bar ${barIndex}`);

    // Highlight drop target
    const target = e.currentTarget as HTMLElement;
    target.classList.add('drop-target');
  }

  private _handleStopDrop(e: DragEvent, barIndex: number, targetStopId: string) {
    e.preventDefault();

    // Remove highlight
    const target = e.currentTarget as HTMLElement;
    target.classList.remove('drop-target');

    // Get dragged item data
    const data = JSON.parse(e.dataTransfer!.getData('application/json'));
    const sourceBarIndex = data.barIndex;
    const sourceStopId = data.stopId;

    // Only handle drops within the same bar for now
    if (sourceBarIndex !== barIndex) return;

    // Get the bars and stops
    const bars = [...(this.config.bars || [])];
    if (!bars[barIndex]) return;

    const bar = { ...bars[barIndex] };
    if (!bar.gradient_stops || bar.gradient_stops.length < 2) return;

    // Get source and target indices
    const stops = [...bar.gradient_stops];
    const sourceIndex = stops.findIndex(stop => stop.id === sourceStopId);
    const targetIndex = stops.findIndex(stop => stop.id === targetStopId);

    if (sourceIndex === -1 || targetIndex === -1) return;

    // Reorder the stops
    const stopToMove = stops[sourceIndex];
    stops.splice(sourceIndex, 1);
    stops.splice(targetIndex, 0, stopToMove);

    // Update the bar with reordered stops
    bar.gradient_stops = stops;
    bars[barIndex] = bar;

    // Update config
    this._updateConfig({ bars });
  }

  private _getGradientToggleSchema(index: number) {
    return [
      {
        name: `bars.${index}.use_gradient`,
        selector: { boolean: {} },
        label: 'Use Gradient Mode',
        description:
          'Enable to use a color gradient based on the bar position. The bar will display the color from the gradient that corresponds to the current percentage.',
      },
    ];
  }

  // Method for animation options schema
  private _getAnimationSchema(index: number) {
    return [
      {
        name: `bars.${index}.animation_entity`,
        selector: { entity: {} },
        label: 'Action Entity',
        description: 'Entity whose state will trigger an animation on the bar.',
      },
      {
        name: `bars.${index}.animation_state`,
        selector: { text: {} },
        label: 'Entity State',
        description: 'When the entity matches this state, the animation will be triggered.',
      },
      {
        name: `bars.${index}.animation_type`,
        selector: {
          select: {
            options: BAR_ANIMATION_OPTIONS,
            mode: 'dropdown',
          },
        },
        label: 'Animation Type',
        description: 'Choose the animation to display when the entity state matches.',
      },
    ];
  }

  async connectedCallback() {
    super.connectedCallback();

    // Add a small delay to ensure the config is loaded
    setTimeout(() => {
      // Check if we have a base64 image that needs to be fixed
      this._checkAndFixBase64Images();
    }, 1000);
  }

  // Function to detect and fix base64 images
  private async _checkAndFixBase64Images() {
    // Fix vehicle_image if it's base64
    if (
      this.config &&
      this.config.vehicle_image &&
      typeof this.config.vehicle_image === 'string' &&
      this.config.vehicle_image.startsWith('data:image/')
    ) {
      console.log('[BASE64 FIX] Detected base64 image in vehicle_image. Attempting to repair...');

      try {
        // Convert base64 to blob
        const base64Data = this.config.vehicle_image;
        const byteString = atob(base64Data.split(',')[1]);
        const mimeType = base64Data.split(',')[0].split(':')[1].split(';')[0];

        const ab = new ArrayBuffer(byteString.length);
        const ia = new Uint8Array(ab);
        for (let i = 0; i < byteString.length; i++) {
          ia[i] = byteString.charCodeAt(i);
        }

        // Create a blob and then a File object
        const blob = new Blob([ab], { type: mimeType });
        const filename = `vehicle_image_${Date.now()}.${mimeType.split('/')[1]}`;
        const file = new File([blob], filename, { type: mimeType });

        console.log('[BASE64 FIX] Created file object from base64:', filename);

        // Alert user
        alert('Converting base64 vehicle image to proper image path...');

        // Upload to Home Assistant
        const formData = new FormData();
        formData.append('file', file);

        console.log('[BASE64 FIX] Uploading to Home Assistant...');

        // Get the token
        const token = this.hass.auth.data.access_token;

        // Upload the file
        const response = await fetch('/api/image_upload', {
          method: 'POST',
          headers: {
            Authorization: `Bearer ${token}`,
          },
          body: formData,
        });

        if (!response.ok) {
          throw new Error(`Upload failed: ${response.statusText}`);
        }

        const data = await response.json();
        console.log('[BASE64 FIX] Upload successful:', data);

        if (!data || !data.path) {
          throw new Error('Invalid response from server: missing path');
        }

        // Save the path to config
        const newConfig = { ...this.config };
        newConfig.vehicle_image = data.path;

        // Update the config
        this._updateConfig(newConfig);

        console.log('[BASE64 FIX] Configuration updated with proper path instead of base64');
        alert(
          'Your vehicle image has been converted from base64 to a proper Home Assistant image path, improving performance and reducing config size.'
        );
      } catch (error) {
        console.error('[BASE64 FIX] Error repairing base64 image:', error);
        alert(
          `Error fixing base64 image: ${error instanceof Error ? error.message : 'Unknown error'}`
        );
      }
    }

    // Fix action_images if they're base64
    if (this.config && this.config.action_images) {
      // Create a copy of the config to avoid direct manipulation
      const newConfig = { ...this.config };
      let changesCount = 0;

      // Loop through each entity in action_images
      for (const entityId in this.config.action_images) {
        if (Object.prototype.hasOwnProperty.call(this.config.action_images, entityId)) {
          const entityStates = this.config.action_images[entityId];

          // Loop through each state in the entity
          for (const state in entityStates) {
            if (Object.prototype.hasOwnProperty.call(entityStates, state)) {
              const imagePath = entityStates[state];

              // Check if this is a base64 image
              if (typeof imagePath === 'string' && imagePath.startsWith('data:image/')) {
                console.log(
                  `[BASE64 FIX] Detected base64 image in action_images for ${entityId}/${state}. Attempting to repair...`
                );

                try {
                  // Convert base64 to blob
                  const base64Data = imagePath;
                  const byteString = atob(base64Data.split(',')[1]);
                  const mimeType = base64Data.split(',')[0].split(':')[1].split(';')[0];

                  const ab = new ArrayBuffer(byteString.length);
                  const ia = new Uint8Array(ab);
                  for (let i = 0; i < byteString.length; i++) {
                    ia[i] = byteString.charCodeAt(i);
                  }

                  // Create a blob and then a File object
                  const blob = new Blob([ab], { type: mimeType });
                  const filename = `action_image_${entityId}_${state}_${Date.now()}.${mimeType.split('/')[1]}`;
                  const file = new File([blob], filename, { type: mimeType });

                  console.log('[BASE64 FIX] Created file object from base64:', filename);

                  // Upload to Home Assistant
                  const formData = new FormData();
                  formData.append('file', file);

                  // Get the token
                  const token = this.hass.auth.data.access_token;

                  // Upload the file
                  const response = await fetch('/api/image_upload', {
                    method: 'POST',
                    headers: {
                      Authorization: `Bearer ${token}`,
                    },
                    body: formData,
                  });

                  if (!response.ok) {
                    throw new Error(`Upload failed: ${response.statusText}`);
                  }

                  const data = await response.json();
                  console.log('[BASE64 FIX] Upload successful:', data);

                  if (!data || !data.path) {
                    throw new Error('Invalid response from server: missing path');
                  }

                  // Make sure newConfig has the action_images structure
                  if (!newConfig.action_images) {
                    newConfig.action_images = {};
                  }
                  if (!newConfig.action_images[entityId]) {
                    newConfig.action_images[entityId] = {};
                  }

                  // Update the path in our copied config
                  newConfig.action_images[entityId][state] = data.path;
                  changesCount++;

                  console.log(
                    `[BASE64 FIX] Updated action image for ${entityId}/${state} with proper path instead of base64`
                  );
                } catch (error) {
                  console.error(
                    `[BASE64 FIX] Error repairing base64 image for ${entityId}/${state}:`,
                    error
                  );
                }
              }
            }
          }
        }
      }

      // Update the config if we made changes
      if (changesCount > 0) {
        this._updateConfig(newConfig);
        console.log(
          `[BASE64 FIX] Updated ${changesCount} action images from base64 to proper paths`
        );
        alert(
          `${changesCount} action images have been converted from base64 to proper Home Assistant image paths.`
        );
      }
    }
  }
}
