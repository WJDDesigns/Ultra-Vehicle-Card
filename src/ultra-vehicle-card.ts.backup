import { LitElement, html, css } from 'lit';
import { customElement, property } from 'lit/decorators.js';
import { HomeAssistant } from 'custom-card-helpers';
import { UltraVehicleCardConfig, IconRowConfig, IconConfig } from './types';
import './editor/ultra-vehicle-card-editor';

// Updated path with correct capitalization
const DEFAULT_VEHICLE_IMAGE = '/hacsfiles/Ultra-Vehicle-Card/assets/default-car.png';

@customElement('ultra-vehicle-card')
export class UltraVehicleCard extends LitElement {
  @property({ attribute: false }) public hass!: HomeAssistant;
  @property() private config!: UltraVehicleCardConfig;
  // Add card version to force cache refresh
  private _cardVersion = '1.2.0-debug';
  private _debugMode = true;

  static getConfigElement() {
    return document.createElement('ultra-vehicle-card-editor');
  }

  static getStubConfig() {
    return {
      title: 'Vehicle Title',
      title_alignment: 'center',
      formatted_entities: true,
      // Other defaults...
    };
  }

  static get properties() {
    return {
      hass: {},
      config: {},
    };
  }

  static get styles() {
    return css`
      :host {
        --card-primary-color: var(--primary-color, #03a9f4);
        --card-secondary-color: var(--secondary-color, #67828c);
        --card-background-color: var(--card-background-color, var(--ha-card-background, white));
        --card-text-color: var(--primary-text-color, #212121);
        --card-secondary-text-color: var(--secondary-text-color, #727272);
        --card-disabled-text-color: var(--disabled-text-color, #bdbdbd);
        --card-icon-color: var(--paper-item-icon-color, #44739e);
        --card-icon-active-color: var(--paper-item-icon-active-color, #fdd835);
        --ha-bar-primary-color: var(--primary-color, #03a9f4);
        --ha-bar-secondary-color: rgba(3, 169, 244, 0.1);
        --ha-bar-border-color: rgba(3, 169, 244, 0.4);

        /* Default spacing variables */
        --card-padding: 16px;
        --card-margin: 8px;
      }

      /* Main container styles */
      ha-card {
        display: flex;
        flex-direction: column;
        margin: var(--card-margin);
        overflow: hidden;
        padding: var(--card-padding);
        background-color: var(--card-background-color);
        color: var(--card-text-color);
        border-radius: var(--ha-card-border-radius, 4px);
        box-shadow: var(
          --ha-card-box-shadow,
          0 2px 2px 0 rgba(0, 0, 0, 0.14),
          0 1px 5px 0 rgba(0, 0, 0, 0.12),
          0 3px 1px -2px rgba(0, 0, 0, 0.2)
        );
      }

      /* Image upload placeholder and styles */
      .vehicle-image-placeholder {
        display: flex;
        align-items: center;
        justify-content: center;
        min-height: 150px;
        border: 2px dashed var(--card-secondary-text-color);
        border-radius: 8px;
        margin: 8px 0;
        background: rgba(0, 0, 0, 0.03);
      }

      .upload-placeholder {
        display: flex;
        flex-direction: column;
        align-items: center;
        justify-content: center;
        padding: 20px;
        text-align: center;
      }

      .placeholder-icon {
        font-size: 48px;
        color: var(--card-secondary-text-color);
        margin-bottom: 12px;
      }

      .placeholder-text {
        margin-bottom: 16px;
        color: var(--card-secondary-text-color);
      }

      .placeholder-text p {
        margin: 4px 0;
      }

      .upload-button {
        --mdc-theme-primary: var(--card-primary-color);
        margin-top: 8px;
      }

      .image-error {
        position: relative;
        border: 1px solid #f44336;
        border-radius: 4px;
      }

      /* Vehicle image container */
      .vehicle-image-container {
        position: relative;
        display: flex;
        justify-content: center;
        align-items: center;
        margin-bottom: 8px;
      }

      .vehicle-image {
        width: 100%;
        height: auto;
        object-fit: contain;
      }

      /* Card title */
      .card-title {
        font-size: 1.2rem;
        font-weight: 500;
        margin-bottom: 12px;
        user-select: none;
      }

      .title-left {
        text-align: left;
      }

      .title-center {
        text-align: center;
      }

      .title-right {
        text-align: right;
      }

      /* Vehicle info section */
      .vehicle-info {
        display: flex;
        flex-direction: column;
        padding: 8px 0;
      }

      .info-item {
        display: flex;
        justify-content: space-between;
        align-items: center;
        margin: 4px 0;
      }

      .info-item-label {
        font-weight: 500;
        margin-right: 8px;
      }

      .info-item-value {
        color: var(--card-secondary-text-color);
      }

      /* Bar styles */
      .bar-container {
        margin: 8px 0;
        width: var(--bar-width, 100%);
      }

      .bar-header {
        display: flex;
        justify-content: var(--bar-alignment, space-between);
        align-items: center;
        margin-bottom: 4px;
      }

      .bar-label {
        font-weight: 500;
        font-size: 0.9rem;
      }

      .bar-value {
        font-size: 0.9rem;
        color: var(--card-secondary-text-color);
      }

      .bar-background,
      .progress-bar {
        height: var(--bar-height, 8px);
        width: 100%;
        background-color: var(--ha-bar-secondary-color);
        border-radius: 4px;
        overflow: hidden;
        position: relative;
        border: 1px solid var(--ha-bar-border-color);
      }

      .bar-fill,
      .progress-bar-fill {
        height: 100%;
        background-color: var(--ha-bar-primary-color);
        position: absolute;
        top: 0;
        left: 0;
        transition: width 0.5s ease;
      }

      /* Animation styles */
      @keyframes chargingAnimation {
        0% {
          background-position: 0 0;
        }
        100% {
          background-position: 50px 50px;
        }
      }

      @keyframes fillingAnimation {
        0% {
          width: 0% !important;
        }
        100% {
          width: 100% !important;
        }
      }

      @keyframes pulsingAnimation {
        0% {
          opacity: 1;
        }
        50% {
          opacity: 0.5;
        }
        100% {
          opacity: 1;
        }
      }

      @keyframes blinkingAnimation {
        0% {
          opacity: 1;
        }
        49% {
          opacity: 1;
        }
        50% {
          opacity: 0;
        }
        99% {
          opacity: 0;
        }
        100% {
          opacity: 1;
        }
      }

      @keyframes bouncingAnimation {
        0% {
          transform: scaleY(1);
        }
        50% {
          transform: scaleY(0.8);
        }
        100% {
          transform: scaleY(1);
        }
      }

      .bar-fill.animation-charging,
      .progress-bar-fill.animation-charging {
        background-image: linear-gradient(
          -45deg,
          rgba(255, 255, 255, 0.5) 25%,
          transparent 25%,
          transparent 50%,
          rgba(255, 255, 255, 0.5) 50%,
          rgba(255, 255, 255, 0.5) 75%,
          transparent 75%,
          transparent
        ) !important;
        background-size: 30px 30px !important;
        animation: chargingAnimation 1s linear infinite !important;
        z-index: 10 !important;
      }

      .bar-fill.animation-filling,
      .progress-bar-fill.animation-filling {
        animation: fillingAnimation 3s ease-in-out infinite alternate !important;
        z-index: 10 !important;
      }

      .bar-fill.animation-pulsing,
      .progress-bar-fill.animation-pulsing {
        animation: pulsingAnimation 1.5s ease-in-out infinite !important;
        z-index: 10 !important;
      }

      .bar-fill.animation-blinking,
      .progress-bar-fill.animation-blinking {
        animation: blinkingAnimation 1s step-end infinite !important;
        z-index: 10 !important;
      }

      .bar-fill.animation-bouncing,
      .progress-bar-fill.animation-bouncing {
        animation: bouncingAnimation 0.8s ease-in-out infinite !important;
        transform-origin: center !important;
        z-index: 10 !important;
      }

      /* Icon Row Styles */
      .icon-row {
        display: flex;
        justify-content: var(--icon-row-justify, space-between);
        margin: 8px 0;
        width: var(--icon-row-width, 100%);
        gap: var(--icon-row-gap, 8px);
      }

      .icon-container {
        display: flex;
        flex-direction: column;
        align-items: center;
        cursor: pointer;
        padding: 8px;
        border-radius: 4px;
        transition: background-color 0.2s;
        flex: 1;
        position: relative;
      }

      .icon-container:hover {
        background-color: rgba(0, 0, 0, 0.05);
      }

      .icon-container:active {
        background-color: rgba(0, 0, 0, 0.1);
      }

      .action-icon {
        font-size: var(--mdc-icon-size, 24px);
        height: var(--mdc-icon-height, 24px);
        width: var(--mdc-icon-width, 24px);
        margin-bottom: 4px;
      }

      .icon-text {
        font-size: 0.8rem;
        text-align: center;
        white-space: nowrap;
        overflow: hidden;
        text-overflow: ellipsis;
        max-width: 100%;
        color: var(--card-secondary-text-color);
      }

      /* Vertical alignment within icon containers */
      .icon-container[data-position='top'],
      .icon-container.position-top {
        justify-content: flex-start;
      }

      .icon-container[data-position='center'],
      .icon-container.position-center {
        justify-content: center;
      }

      .icon-container[data-position='bottom'],
      .icon-container.position-bottom {
        justify-content: flex-end;
      }

      /* Horizontal text position */
      .icon-container[data-position='left'].position-left,
      .icon-container.position-left {
        flex-direction: row-reverse !important;
      }

      .icon-container[data-position='right'].position-right,
      .icon-container.position-right {
        flex-direction: row !important;
      }
    `;
  }

  /**
   * Helper to detect if a string is a base64 image
   */
  private _isBase64Image(imageUrl: string): boolean {
    if (!imageUrl || typeof imageUrl !== 'string') {
      console.log('[BASE64 CHECK] Not a string or empty:', imageUrl);
      return false;
    }

    // Check if it starts with data:image/
    const isBase64 = imageUrl.startsWith('data:image/');
    console.log(
      '[BASE64 CHECK] Checking if image is base64:',
      imageUrl.substring(0, 30) + '...',
      isBase64 ? 'IS BASE64' : 'NOT base64'
    );
    return isBase64;
  }

  /**
   * Migrate legacy sections to individual sections
   */
  private _migrateSections() {
    // Make sure we have a sections_order array to work with
    if (!this.config.sections_order) {
      this.config.sections_order = ['title', 'image', 'info'];
    }

    // Get a copy of the current sections and ensure arrays are initialized
    let sections = [...this.config.sections_order];
    const bars = this.config.bars ?? [];
    const iconRows = this.config.icon_rows ?? [];

    let changed = false;

    console.log('Migrating sections, current sections:', sections);
    console.log('Current bars:', bars.length);
    console.log('Current icon rows:', iconRows.length);

    // Check if we have the legacy 'bars' section but also have bars defined
    const barsIndex = sections.indexOf('bars');
    if (barsIndex !== -1 && bars.length > 0) {
      // Replace with individual bar sections
      const barSections = bars.map((_, idx) => `bar_${idx}`);
      sections.splice(barsIndex, 1, ...barSections);
      changed = true;
      console.log('Replaced bars section with individual bars:', barSections);
    } else if (barsIndex === -1 && bars.length > 0) {
      // If we have bars but no 'bars' section, add individual bar sections after 'info'
      const infoIndex = sections.indexOf('info');
      if (infoIndex !== -1) {
        const barSections = bars.map((_, idx) => `bar_${idx}`);
        sections.splice(infoIndex + 1, 0, ...barSections);
        console.log('Added bar sections after info:', barSections);
      } else {
        // Or just append them
        const barSections = bars.map((_, idx) => `bar_${idx}`);
        sections = [...sections, ...barSections];
        console.log('Appended bar sections at the end:', barSections);
      }
      changed = true;
    }

    // Same for icon rows
    const iconsIndex = sections.indexOf('icons');
    if (iconsIndex !== -1 && iconRows.length > 0) {
      // Replace with individual icon row sections
      const iconRowSections = iconRows.map(row => `icon_row_${row.id}`);
      sections.splice(iconsIndex, 1, ...iconRowSections);
      changed = true;
      console.log('Replaced icons section with individual icon rows:', iconRowSections);
    } else if (iconsIndex === -1 && iconRows.length > 0) {
      // If we have icon rows but no 'icons' section, add them at the end
      const iconRowSections = iconRows.map(row => `icon_row_${row.id}`);
      sections = [...sections, ...iconRowSections];
      changed = true;
      console.log('Appended icon rows at the end:', iconRowSections);
    }

    // Update config if changes were made
    if (changed) {
      console.log('Updated sections_order:', sections);
      this.config.sections_order = sections;
    } else {
      console.log('No changes made to sections_order');
    }

    // Emergency fallback - if no bars are in the sections but we have bars, force add them
    const hasBarsInSections = sections.some(
      section => section.startsWith('bar_') || section === 'bars'
    );
    if (!hasBarsInSections && bars.length > 0) {
      console.log('EMERGENCY FIX: Adding bars to sections_order because they were missing');
      this.config.sections_order = [...sections, ...bars.map((_, idx) => `bar_${idx}`)];
    }

    // Emergency fallback - if no icon rows are in the sections but we have icon rows, force add them
    const hasIconsInSections = sections.some(
      section => section.startsWith('icon_row_') || section === 'icons'
    );
    if (!hasIconsInSections && iconRows.length > 0) {
      console.log('EMERGENCY FIX: Adding icon rows to sections_order because they were missing');
      this.config.sections_order = [...sections, ...iconRows.map(row => `icon_row_${row.id}`)];
    }
  }

  setConfig(config: UltraVehicleCardConfig) {
    if (!config) {
      throw new Error('Invalid configuration');
    }

    // First, create a basic copy of the config
    const defaultConfig = { ...config };
    console.log(
      '[CONFIG DEBUG] Initial config:',
      JSON.stringify({
        vehicle_image_type: defaultConfig.vehicle_image_type,
        vehicle_image: defaultConfig.vehicle_image
          ? defaultConfig.vehicle_image.substring(0, 30) + '...'
          : undefined,
      })
    );

    // Then apply default values for missing properties
    if (defaultConfig.vehicle_image_type === undefined) {
      defaultConfig.vehicle_image_type = 'default';
      console.log(
        '[CONFIG DEBUG] Setting default vehicle_image_type:',
        defaultConfig.vehicle_image_type
      );
    }

    // CRITICAL CHECK: If image type is set to 'upload' but we have a base64 image,
    // this means the image upload failed to use the API path properly
    if (
      defaultConfig.vehicle_image_type === 'upload' &&
      typeof defaultConfig.vehicle_image === 'string' &&
      this._isBase64Image(defaultConfig.vehicle_image)
    ) {
      console.error(
        '[CRITICAL ERROR] Upload type is set but image is base64 - image upload API is not working properly!'
      );
      console.error(
        '[CRITICAL ERROR] Replace base64 image with a placeholder and show an error to the user'
      );

      // Replace with a placeholder image
      defaultConfig.vehicle_image = '/hacsfiles/Ultra-Vehicle-Card/assets/error-image.png';

      // Show a critical error to the user
      setTimeout(() => {
        alert(
          'CRITICAL ERROR: Image upload is not working correctly. The image was stored as base64 instead of using the API path. ' +
            'This will cause severe performance issues. Please check if your Home Assistant instance supports the /api/image_upload endpoint ' +
            'and that the authentication is working properly. A placeholder image has been used instead.'
        );
      }, 500);
    }

    // Check for and automatically clean base64 images to reduce config size
    let cleanedImages = 0;

    // Remove base64 images to reduce config size
    if (
      typeof defaultConfig.vehicle_image === 'string' &&
      this._isBase64Image(defaultConfig.vehicle_image)
    ) {
      console.log('[CONFIG DEBUG] Detected base64 vehicle image, replacing with placeholder');
      const originalValue = defaultConfig.vehicle_image.substring(0, 30) + '...';
      defaultConfig.vehicle_image = '/hacsfiles/Ultra-Vehicle-Card/assets/car-uploaded.png';
      console.log(
        '[CONFIG DEBUG] Changed vehicle_image from base64',
        originalValue,
        'to',
        defaultConfig.vehicle_image
      );
      cleanedImages++;
    }

    // Check for base64 in action_images
    if (defaultConfig.action_images) {
      const actionImages = defaultConfig.action_images;
      Object.keys(actionImages).forEach(entity => {
        const entityImages = actionImages[entity];
        if (entityImages) {
          Object.keys(entityImages).forEach(state => {
            const imageUrl = entityImages[state];
            if (typeof imageUrl === 'string' && this._isBase64Image(imageUrl)) {
              console.log(
                `[IMAGE] Detected base64 action image for ${entity}/${state}, replacing with placeholder`
              );
              entityImages[state] = '/hacsfiles/Ultra-Vehicle-Card/assets/car-uploaded.png';
              cleanedImages++;
            }
          });
        }
      });
    }

    // Notify user if images were cleaned
    if (cleanedImages > 0) {
      const plural = cleanedImages === 1 ? '' : 's';
      this._showNotification(
        `Cleaned ${cleanedImages} base64 image${plural} from configuration. Please save your configuration to reduce YAML size.`,
        'info'
      );
    }

    // Fix the type mismatch - only use allowed values
    if (!['entity', 'none', 'upload'].includes(defaultConfig.status_image_type as string)) {
      defaultConfig.status_image_type = 'none';
    }

    // Handle other defaults
    if (defaultConfig.layout_type === undefined) {
      defaultConfig.layout_type = 'single';
    }

    // Specifically ensure formatted_entities is a boolean
    defaultConfig.formatted_entities = defaultConfig.formatted_entities === true;
    console.log(`[CONFIG] Formatted entities is set to: ${defaultConfig.formatted_entities}`);

    if (!defaultConfig.bars) {
      defaultConfig.bars = [];
    }

    if (!defaultConfig.icon_rows) {
      defaultConfig.icon_rows = [];
    }

    // Set default section order if not provided
    if (!defaultConfig.sections_order) {
      defaultConfig.sections_order = ['title', 'image', 'info', 'bars', 'icons'];
    } else if (!defaultConfig.sections_order.includes('info')) {
      // Create a new array to avoid modifying a potentially frozen array
      const newSectionsOrder = [...defaultConfig.sections_order];

      // Add 'info' section after 'image' if it doesn't exist
      const imageIndex = newSectionsOrder.indexOf('image');
      if (imageIndex !== -1) {
        // Add info after image
        newSectionsOrder.splice(imageIndex + 1, 0, 'info');
      } else {
        // Or add it at the start if 'image' isn't found
        newSectionsOrder.unshift('info');
      }

      // Update the config with the new array
      defaultConfig.sections_order = newSectionsOrder;
    }

    // Ensure defaults for vehicle info settings
    if (defaultConfig.show_location === undefined) {
      defaultConfig.show_location = true;
    }
    if (defaultConfig.show_mileage === undefined) {
      defaultConfig.show_mileage = true;
    }
    if (defaultConfig.show_car_state === undefined) {
      defaultConfig.show_car_state = true;
    }

    this.config = defaultConfig;

    // Apply default widths if not set
    if (this.config.vehicle_image_width === undefined) {
      this.config.vehicle_image_width = 100;
    }

    if (this.config.action_image_width === undefined) {
      this.config.action_image_width = 100;
    }

    // Migrate any existing bars and icon rows to individual sections
    this._migrateSections();

    console.log('Card config:', JSON.stringify(this.config));
  }

  /**
   * Display a notification message to the user
   */
  private _showNotification(message: string, type: 'info' | 'warning' | 'error' = 'info') {
    // Create a notification element
    const notification = document.createElement('div');
    notification.textContent = message;
    notification.style.position = 'fixed';
    notification.style.bottom = '20px';
    notification.style.left = '20px';
    notification.style.padding = '12px 20px';
    notification.style.borderRadius = '4px';
    notification.style.boxShadow = '0 2px 8px rgba(0,0,0,0.2)';
    notification.style.zIndex = '9999';
    notification.style.fontSize = '14px';
    notification.style.maxWidth = '400px';
    notification.style.wordBreak = 'break-word';

    // Set color based on type
    if (type === 'info') {
      notification.style.backgroundColor = 'var(--primary-color, #03a9f4)';
      notification.style.color = 'white';
    } else if (type === 'warning') {
      notification.style.backgroundColor = 'var(--warning-color, #ff9800)';
      notification.style.color = 'white';
    } else if (type === 'error') {
      notification.style.backgroundColor = 'var(--error-color, #f44336)';
      notification.style.color = 'white';
    }

    // Add to the DOM
    document.body.appendChild(notification);

    // Remove after 8 seconds with a fade out effect
    setTimeout(() => {
      notification.style.transition = 'opacity 0.5s ease-out';
      notification.style.opacity = '0';

      // Remove from DOM after transition completes
      setTimeout(() => {
        if (document.body.contains(notification)) {
          document.body.removeChild(notification);
        }
      }, 500);
    }, 8000);
  }

  protected render() {
    if (!this.config || !this.hass) {
      return html``;
    }

    // Version check debugging output
    console.log(`[VERSION] Ultra Vehicle Card v${this._cardVersion}`);

    // Make sure config has arrays initialized
    const bars = this.config.bars ?? [];
    const iconRows = this.config.icon_rows ?? [];

    // Add direct debugging output
    const debugOutput = this._debugMode
      ? html`
          <div
            style="background: rgba(255,0,0,0.1); border: 1px solid red; padding: 8px; margin-bottom: 16px; font-size: 12px;"
          >
            <div style="font-weight: bold; margin-bottom: 4px;">
              Debug Info v${this._cardVersion}
            </div>
            <div>Icons: ${iconRows.length} rows</div>
            <div>Bars: ${bars.length} configured</div>
            <div style="margin-top: 8px; font-weight: bold; color: blue;">Animation Debug:</div>
            ${bars.map((bar, idx) => {
              const animEntity = bar.action_animation_entity;
              const animState = bar.action_animation_state;
              const animType = bar.action_animation;
              const currentState = animEntity
                ? this.hass.states[animEntity]?.state || 'unknown'
                : 'none';
              const isMatching =
                animEntity && animState && currentState.toLowerCase() === animState.toLowerCase();

              return html`
                <div style="margin: 4px 0; ${isMatching ? 'color: green;' : ''}">
                  Bar ${idx + 1}: ${animEntity ? animEntity : 'No entity'} → Current:
                  "${currentState}" / Target: "${animState || 'none'}" / Animation:
                  ${animType || 'none'} ${isMatching ? '✅ ACTIVE' : '❌ inactive'}
                </div>
              `;
            })}
          </div>
        `
      : '';

    // Add inline styles for animations - force them to apply to all progress-bar-fill elements
    const animationStyles = html`
      <style>
        /* Direct animation styles */
        @keyframes cardChargingAnimation {
          0% {
            background-position: 0 0 !important;
          }
          100% {
            background-position: 50px 50px !important;
          }
        }

        @keyframes cardFillingAnimation {
          0% {
            width: 0% !important;
          }
          100% {
            width: 100% !important;
          }
        }

        @keyframes cardPulsingAnimation {
          0% {
            opacity: 1 !important;
          }
          50% {
            opacity: 0.5 !important;
          }
          100% {
            opacity: 1 !important;
          }
        }

        @keyframes cardBlinkingAnimation {
          0% {
            opacity: 1 !important;
          }
          49% {
            opacity: 1 !important;
          }
          50% {
            opacity: 0 !important;
          }
          99% {
            opacity: 0 !important;
          }
          100% {
            opacity: 1 !important;
          }
        }

        @keyframes cardBouncingAnimation {
          0% {
            transform: scaleY(1) !important;
          }
          50% {
            transform: scaleY(0.8) !important;
          }
          100% {
            transform: scaleY(1) !important;
          }
        }

        /* Force these to apply to any element with these classes */
        .card-content .progress-bar-fill.animation-charging {
          background-image: linear-gradient(
            -45deg,
            rgba(255, 255, 255, 0.5) 25%,
            transparent 25%,
            transparent 50%,
            rgba(255, 255, 255, 0.5) 50%,
            rgba(255, 255, 255, 0.5) 75%,
            transparent 75%,
            transparent
          ) !important;
          background-size: 30px 30px !important;
          animation: cardChargingAnimation 1s linear infinite !important;
          z-index: 100 !important;
        }

        .card-content .progress-bar-fill.animation-filling {
          animation: cardFillingAnimation 3s ease-in-out infinite alternate !important;
          z-index: 100 !important;
        }

        .card-content .progress-bar-fill.animation-pulsing {
          animation: cardPulsingAnimation 1.5s ease-in-out infinite !important;
          z-index: 100 !important;
        }

        .card-content .progress-bar-fill.animation-blinking {
          animation: cardBlinkingAnimation 1s step-end infinite !important;
          z-index: 100 !important;
        }

        .card-content .progress-bar-fill.animation-bouncing {
          animation: cardBouncingAnimation 0.8s ease-in-out infinite !important;
          transform-origin: center !important;
          z-index: 100 !important;
        }
      </style>
    `;

    // Add a script that will directly inject animations into elements
    const animationScript = html`
      <script>
        // Runs immediately after rendering to force animations
        (() => {
          console.log('[ANIMATION INJECTOR] Starting direct animation injector');

          // Function to apply animations to DOM elements
          const applyAnimations = () => {
            // Find all progress-bar-container elements with animation data
            const containers = document.querySelectorAll(
              '.progress-bar-container[data-animation-entity][data-animation-state][data-animation-type]'
            );

            console.log(
              '[ANIMATION INJECTOR] Found',
              containers.length,
              'bars to check for animations'
            );

            containers.forEach(container => {
              const entity = container.getAttribute('data-animation-entity');
              const targetState = container.getAttribute('data-animation-state');
              const animationType = container.getAttribute('data-animation-type');
              const needsAnimation = container.getAttribute('data-needs-animation') === 'true';

              if (!entity || !targetState || !animationType || animationType === 'none') {
                return;
              }

              // Find the fill element
              const fillElement = container.querySelector('.progress-bar-fill');
              if (!fillElement) {
                console.log('[ANIMATION INJECTOR] No fill element found in container');
                return;
              }

              if (needsAnimation) {
                console.log(
                  '[ANIMATION INJECTOR] Applying animation-' + animationType + ' to element',
                  fillElement
                );

                // Apply animation class
                fillElement.classList.add('animation-' + animationType);

                // Apply direct styles based on animation type
                if (animationType === 'charging') {
                  fillElement.style.backgroundImage =
                    'linear-gradient(-45deg, rgba(255,255,255,0.5) 25%, transparent 25%, transparent 50%, rgba(255,255,255,0.5) 50%, rgba(255,255,255,0.5) 75%, transparent 75%, transparent)';
                  fillElement.style.backgroundSize = '30px 30px';
                  fillElement.style.animation = 'cardChargingAnimation 1s linear infinite';
                } else if (animationType === 'filling') {
                  fillElement.style.width = 'auto';
                  fillElement.style.animation =
                    'cardFillingAnimation 3s ease-in-out infinite alternate';
                } else if (animationType === 'pulsing') {
                  fillElement.style.animation = 'cardPulsingAnimation 1.5s ease-in-out infinite';
                } else if (animationType === 'blinking') {
                  fillElement.style.animation = 'cardBlinkingAnimation 1s step-end infinite';
                } else if (animationType === 'bouncing') {
                  fillElement.style.animation = 'cardBouncingAnimation 0.8s ease-in-out infinite';
                  fillElement.style.transformOrigin = 'center';
                }

                // Set high z-index to ensure it's visible
                fillElement.style.zIndex = '100';
              } else {
                // Remove animation classes if not needed
                fillElement.classList.remove(
                  'animation-charging',
                  'animation-filling',
                  'animation-pulsing',
                  'animation-blinking',
                  'animation-bouncing'
                );
              }
            });
          };

          // Apply animations immediately
          setTimeout(applyAnimations, 10);

          // And again after a longer delay
          setTimeout(applyAnimations, 500);

          // Set up observer to watch for DOM changes
          const observer = new MutationObserver(mutations => {
            console.log('[ANIMATION INJECTOR] DOM changes detected, reapplying animations');
            applyAnimations();
          });

          // Start observing after a short delay to let things settle
          setTimeout(() => {
            const cardContent = document.querySelector('.card-content');
            if (cardContent) {
              observer.observe(cardContent, {
                childList: true,
                subtree: true,
                attributes: true,
                attributeFilter: ['class', 'style'],
              });
              console.log('[ANIMATION INJECTOR] Observer attached to card content');
            }
          }, 200);
        })();
      </script>
    `;

    return html`
      <ha-card>
        ${debugOutput} ${animationStyles} ${animationScript}
        <div
          class="card-content ${this.config.layout_type === 'double' ? 'two-column-layout' : ''}"
        >
          <!-- Regular content -->
          ${this._renderCardContent()}

          <!-- ALWAYS render bars directly -->
          ${bars.length > 0
            ? html`
                <div
                  class="direct-render-container"
                  style="
                    margin-top: 24px;
                    padding: 16px;
                    border: 2px solid var(--primary-color);
                    border-radius: 12px;
                    background: rgba(var(--rgb-primary-color), 0.05);
                  "
                >
                  <div
                    style="
                      font-weight: bold; 
                      margin-bottom: 16px; 
                      color: var(--primary-color);
                      font-size: 16px;
                      text-align: center;
                    "
                  >
                    Direct Bar Rendering (${bars.length} bars)
                  </div>
                  <div class="bars-container">
                    ${bars.map((bar, idx) => {
                      console.log(`[DEBUG] Direct rendering of bar ${idx}`);
                      return this._renderBar(bar);
                    })}
                  </div>
                </div>
              `
            : ''}

          <!-- ALWAYS render icon rows directly -->
          ${iconRows.length > 0
            ? html`
                <div
                  class="direct-render-container"
                  style="
                    margin-top: 24px;
                    padding: 16px;
                    border: 2px solid var(--primary-color);
                    border-radius: 12px;
                    background: rgba(var(--rgb-primary-color), 0.05);
                  "
                >
                  <div
                    style="
                      font-weight: bold; 
                      margin-bottom: 16px; 
                      color: var(--primary-color);
                      font-size: 16px;
                      text-align: center;
                    "
                  >
                    Direct Icon Rendering (${iconRows.length} rows)
                  </div>
                  <div class="forced-icons-container">
                    ${iconRows.map((row, idx) => {
                      console.log(`[DEBUG] Direct rendering of icon row ${idx}`);
                      return this._renderIconRow(row);
                    })}
                  </div>
                </div>
              `
            : ''}
        </div>
      </ha-card>
    `;
  }

  private _renderCardContent() {
    // Get sections order from config
    const sectionsOrder = this.config.sections_order || ['title', 'image', 'info', 'bars', 'icons'];
    const layoutType = this.config.layout_type || 'single';
    const columns = this.config.sections_columns || {};

    console.log('[DEBUG] _renderCardContent - Sections order:', JSON.stringify(sectionsOrder));
    console.log('[DEBUG] _renderCardContent - Layout type:', layoutType);
    console.log('[DEBUG] _renderCardContent - Columns config:', JSON.stringify(columns));
    console.log('[DEBUG] _renderCardContent - Has bars:', (this.config.bars?.length || 0) > 0);
    console.log(
      '[DEBUG] _renderCardContent - Has icons:',
      (this.config.icon_rows?.length || 0) > 0
    );

    // For two-column layout
    if (layoutType === 'double') {
      // Split sections into left and right columns
      const leftSections = sectionsOrder.filter(section => columns[section] !== 'right');
      const rightSections = sectionsOrder.filter(section => columns[section] === 'right');

      console.log('[DEBUG] Two-column layout sections:', {
        left: JSON.stringify(leftSections),
        right: JSON.stringify(rightSections),
      });

      return html`
        <div class="column left-column">
          ${leftSections.map(section => this._renderSection(section))}
        </div>
        <div class="column right-column">
          ${rightSections.map(section => this._renderSection(section))}
        </div>
      `;
    }

    // For single column layout
    console.log(
      '[DEBUG] Rendering single column layout with sections:',
      JSON.stringify(sectionsOrder)
    );
    return html`${sectionsOrder.map((section, idx) => {
      console.log(`[DEBUG] Rendering section ${idx}: ${section}`);
      return this._renderSection(section);
    })}`;
  }

  private _renderSection(section: string) {
    console.log('[DEBUG] _renderSection called for section:', section);

    // Check if this is an individual bar section
    if (section.startsWith('bar_')) {
      const barId = section.substring(4); // Remove 'bar_' prefix
      const barIndex = parseInt(barId);

      console.log(
        `[DEBUG] Rendering bar_${barIndex}`,
        this.config.bars?.[barIndex] ? 'Bar exists' : 'Bar NOT found',
        this.config.bars?.[barIndex]
      );

      // Render the individual bar if it exists
      if (this.config.bars && this.config.bars[barIndex]) {
        // IMPORTANT: Call _renderBar directly instead of simply returning HTML
        const result = html`
          <div class="bar-section" id="bar-section-${barIndex}">
            <div class="bars-container">${this._renderBar(this.config.bars[barIndex])}</div>
          </div>
        `;
        console.log(`[DEBUG] Rendered bar_${barIndex} successfully`);
        return result;
      }
      console.warn(
        `[DEBUG] Bar ${barIndex} not found in config.bars of length ${this.config.bars?.length || 0}`
      );
      return html``; // Return empty if bar doesn't exist
    }

    // Check if this is an individual icon row section
    if (section.startsWith('icon_row_')) {
      const rowId = section.substring(9); // Remove 'icon_row_' prefix

      console.log(`[DEBUG] Rendering icon_row_${rowId}`);

      // Find the icon row with matching ID
      const iconRow = this.config.icon_rows?.find(row => row.id === rowId);
      if (iconRow) {
        console.log('[DEBUG] Found icon row:', iconRow);
        return html`
          <div class="icon-row-section">
            <div class="icon-rows-container">${this._renderIconRow(iconRow)}</div>
          </div>
        `;
      }
      console.warn(`[DEBUG] Icon row ${rowId} not found in config.icon_rows`);
      return html``; // Return empty if icon row doesn't exist
    }

    // Handle standard sections
    switch (section) {
      case 'title':
        console.log('[DEBUG] Rendering title section');
        return this._renderTitle();
      case 'image':
        console.log('[DEBUG] Rendering image section');
        return this._renderImage();
      case 'info':
        console.log('[DEBUG] Rendering info section');
        return this._renderVehicleInfo();
      case 'bars':
        // Legacy support for 'bars' section - render all bars
        console.log(
          '[DEBUG] Rendering all bars section, bars count:',
          this.config.bars?.length || 0
        );
        return html`
          <div class="bars-container">
            ${this.config.bars?.map((bar, i) => {
              console.log(`[DEBUG] Rendering bar ${i} in 'bars' section`);
              // IMPORTANT: Call _renderBar for each bar to ensure animations are applied
              return this._renderBar(bar);
            }) || ''}
          </div>
        `;
      case 'icons':
        // Legacy support for 'icons' section - render all icon rows
        console.log(
          '[DEBUG] Rendering all icon rows section, rows count:',
          this.config.icon_rows?.length || 0
        );
        return this._renderIconRows();
      default:
        console.warn('[DEBUG] Unknown section type:', section);
        return html``; // Unknown section
    }
  }

  private _renderTitle() {
    return this.config.title
      ? html`<h1 class="card-title ${this.config.title_alignment || 'center'}">
          ${this.config.title}
        </h1>`
      : html``;
  }

  private _renderImage() {
    let imageUrl = '';
    console.log('[RENDER DEBUG] Starting _renderImage method');

    // Check if we should display an action image
    if (
      this.config.action_entity &&
      this.config.action_state &&
      this.hass.states[this.config.action_entity]?.state === this.config.action_state &&
      this.config.action_images?.[this.config.action_entity]?.[this.config.action_state]
    ) {
      // Use the action image for the current state
      const imagePath =
        this.config.action_images[this.config.action_entity][this.config.action_state];
      console.log('[RENDER DEBUG] Using action image path:', imagePath);

      if (imagePath) {
        // Handle HA API uploaded image paths
        imageUrl = this._buildHassUrl(imagePath);
        console.log('[RENDER DEBUG] Constructed action image URL:', imageUrl);
      }
    } else {
      // Handle the different image type options
      const imageType = this.config.vehicle_image_type;
      console.log('[RENDER DEBUG] Vehicle image type:', imageType);

      if (imageType === 'upload') {
        // Upload image type uses HA image API paths
        const imagePath = this.config.vehicle_image || '';
        console.log('[RENDER DEBUG] Vehicle image path:', imagePath);

        if (imagePath) {
          // Handle HA API uploaded image paths
          imageUrl = this._buildHassUrl(imagePath);
          console.log('[RENDER DEBUG] Constructed vehicle image URL:', imageUrl);
        }
      } else if (imageType === 'url') {
        imageUrl = this.config.vehicle_image || '';
        console.log('[RENDER DEBUG] URL image type, using direct URL:', imageUrl);
      } else if (imageType === 'entity' && this.config.vehicle_image_entity) {
        const entityState = this.hass.states[this.config.vehicle_image_entity]?.state || '';
        console.log('[RENDER DEBUG] Entity image type, entity state:', entityState);
        imageUrl = entityState;
      } else {
        // Default behavior for any other value (including 'default')
        console.log('[RENDER DEBUG] Using default vehicle image:', DEFAULT_VEHICLE_IMAGE);
        imageUrl = DEFAULT_VEHICLE_IMAGE;
      }
    }

    if (!imageUrl && this.config.vehicle_image_type !== 'none') {
      console.log(
        '[RENDER DEBUG] No image URL determined, falling back to default:',
        DEFAULT_VEHICLE_IMAGE
      );
      imageUrl = DEFAULT_VEHICLE_IMAGE;
    }

    console.log('[RENDER DEBUG] Final image URL to be rendered:', imageUrl);

    if (!imageUrl) {
      console.log('[RENDER DEBUG] No image URL available, returning empty string');
      return '';
    }

    let imageStyle = '';
    let containerStyle = '';

    if (this.config.vehicle_image_width !== undefined) {
      imageStyle += `width: ${this.config.vehicle_image_width}%; height: auto;`;
      console.log('[RENDER DEBUG] Applied width style:', imageStyle);
    }

    if (this.config.vehicle_image_crop) {
      const crop = this.config.vehicle_image_crop;
      containerStyle = `
        margin-top: ${crop.top}px;
        margin-right: ${crop.right}px;
        margin-bottom: ${crop.bottom}px;
        margin-left: ${crop.left}px;
        overflow: hidden;
      `;
      console.log('[RENDER DEBUG] Applied crop style:', containerStyle);
    }

    console.log('[RENDER DEBUG] Returning image HTML with URL:', imageUrl);
    return html`
      <div class="vehicle-image-container" style="${containerStyle}">
        <img
          src="${imageUrl}"
          alt="Vehicle"
          style="
            width: ${this.config.vehicle_image_width || 100}%;
            object-fit: contain;
            ${imageStyle}
          "
          @error=${this._handleImageError}
        />
      </div>
    `;
  }

  // Method to trigger image upload dialog from the card itself
  private _triggerImageUpload(e: Event) {
    e.stopPropagation();

    // Dispatch a custom event that can be caught by the editor
    const event = new CustomEvent('ultra-vehicle-card-upload', {
      bubbles: true,
      composed: true,
      detail: {
        cardId: this.id || Date.now().toString(),
        type: 'vehicle_image',
      },
    });

    this.dispatchEvent(event);
    console.log('[UPLOAD DEBUG] Triggered image upload event');
  }

  // Helper function to build Home Assistant URLs for images
  private _buildHassUrl(path: string): string {
    if (!path) {
      return '';
    }

    // Handle base64 images
    if (path.startsWith('data:image/')) {
      return path;
    }

    // Handle full URLs
    if (path.startsWith('http://') || path.startsWith('https://')) {
      return path;
    }

    // Aggressively sanitize the path to remove any multiple consecutive slashes
    const sanitizedPath = path.replace(/\/+/g, '/');
    console.log(`[URL DEBUG] Sanitized path: ${sanitizedPath} (from original: ${path})`);

    // Get the base URL from Home Assistant
    let baseUrl = '';
    try {
      const rawBaseUrl = (this.hass as any).hassUrl;
      if (typeof rawBaseUrl === 'function') {
        baseUrl = rawBaseUrl();
      } else if (typeof rawBaseUrl === 'string') {
        baseUrl = rawBaseUrl;
      }
    } catch (error) {
      console.warn('[URL DEBUG] Error getting hassUrl:', error);
    }

    // Normalize base URL (always remove trailing slash)
    const normalizedBaseUrl = baseUrl.endsWith('/') ? baseUrl.slice(0, -1) : baseUrl;
    console.log(`[URL DEBUG] Normalized base URL: ${normalizedBaseUrl} (from: ${baseUrl})`);

    // Special handling for image/serve paths
    if (sanitizedPath.includes('/api/image/serve/')) {
      try {
        // Extract the image ID from the path
        const matches = sanitizedPath.match(/\/api\/image\/serve\/([^\/]+)/);
        if (matches && matches[1]) {
          const imageId = matches[1];

          // If no base URL, just return a relative path
          if (!normalizedBaseUrl) {
            return `/api/image/serve/${imageId}/original`;
          }

          // Build final URL with explicit single slash
          const finalUrl = `${normalizedBaseUrl}/api/image/serve/${imageId}/original`;
          console.log(`[URL DEBUG] Final image/serve URL: ${finalUrl}`);
          return finalUrl;
        }
      } catch (error) {
        console.warn('[URL DEBUG] Error processing image/serve path:', error);
      }
    }

    // For all other paths, ensure the path starts with exactly one slash
    const normalizedPath = sanitizedPath.startsWith('/') ? sanitizedPath : `/${sanitizedPath}`;

    // Combine with base URL ensuring exactly one slash between
    const finalUrl = normalizedBaseUrl + normalizedPath;
    console.log(`[URL DEBUG] Final URL constructed: ${finalUrl}`);
    return finalUrl;
  }

  // 2. Add this helper method to sanitize paths when they're first stored in the config:

  private _sanitizeImagePath(path: string): string {
    if (!path) return '';

    // Don't modify base64 or full URLs
    if (
      path.startsWith('data:image/') ||
      path.startsWith('http://') ||
      path.startsWith('https://')
    ) {
      return path;
    }

    // Otherwise sanitize by removing consecutive slashes
    return path.replace(/\/+/g, '/');
  }

  // 3. Find the handleFileUpload method in ultra-vehicle-card-editor.ts and modify it to sanitize paths:

  private async handleFileUpload(ev: Event, configKey: string) {
    const input = ev.target as HTMLInputElement;
    const file = input.files?.[0];

    if (file) {
      try {
        console.log('[UPLOAD DEBUG] Starting upload to Home Assistant API for', configKey);

        // Use the uploadImage utility function
        const { uploadImage } = await import('./utils/image-upload');
        const result = await uploadImage(this.hass, file);

        if (!result.success) {
          throw new Error(result.error || 'Failed to upload image');
        }

        console.log('[UPLOAD DEBUG] Upload successful, path:', result.path);

        // ADDED: Sanitize the path before storing in config
        const sanitizedPath = result.path.replace(/\/+/g, '/');
        console.log('[UPLOAD DEBUG] Sanitized path for config:', sanitizedPath);

        // Update the config with the proper path
        this._updateConfig({
          [configKey]: sanitizedPath,
        });
      } catch (error) {
        console.error('[UPLOAD DEBUG] Error uploading file:', error);
        alert(
          'Failed to upload image. Please try again or upload the image manually to the Media Library.'
        );
      }
    }
  }

  // 4. Find the _handleActionImageUpload method and make similar changes there:

  private async _handleActionImageUpload(e: Event) {
    const input = e.target as HTMLInputElement;
    if (!input.files || !input.files[0]) {
      console.log('[ACTION UPLOAD DEBUG] No file selected');
      return;
    }

    const file = input.files[0];

    // Get action entity and state from config
    const actionEntity = this.config.action_entity || '';
    const actionState = this.config.action_state || '';

    if (!actionEntity || !actionState) {
      console.log('[ACTION UPLOAD DEBUG] Missing action entity or state');
      alert('Please select an action entity and state first');
      return;
    }

    console.log(
      `[ACTION UPLOAD DEBUG] Processing file ${file.name} for ${actionEntity}/${actionState}`
    );

    try {
      console.log('[ACTION UPLOAD DEBUG] Starting upload to Home Assistant API');

      // Create form data for the API request
      const formData = new FormData();
      formData.append('file', file);

      // Get the Home Assistant auth token
      const token = this.hass.auth.data.access_token;

      console.log('[ACTION UPLOAD DEBUG] Sending request to /api/image_upload endpoint');

      // Upload the file to Home Assistant's image_upload API
      const response = await fetch('/api/image_upload', {
        method: 'POST',
        headers: {
          Authorization: `Bearer ${token}`,
        },
        body: formData,
      });

      if (!response.ok) {
        throw new Error(`Failed to upload image: ${response.statusText}`);
      }

      const data = await response.json();
      console.log('[ACTION UPLOAD DEBUG] Image upload response:', data);

      if (!data || !data.path) {
        throw new Error('Invalid response from server: missing path');
      }

      // ADDED: Sanitize the path before storing
      const imagePath = data.path.replace(/\/+/g, '/');
      console.log('[ACTION UPLOAD DEBUG] Sanitized image path:', imagePath);

      // Create a deep copy of the config
      const newConfig = JSON.parse(JSON.stringify(this.config));
      console.log(
        '[ACTION UPLOAD DEBUG] Config before update:',
        JSON.stringify(newConfig.action_images || {})
      );

      // Initialize action_images if needed
      if (!newConfig.action_images) {
        newConfig.action_images = {};
      }

      // Initialize entity entry if needed
      if (!newConfig.action_images[actionEntity]) {
        newConfig.action_images[actionEntity] = {};
      }

      // Store the image path from the API, not base64 data
      newConfig.action_images[actionEntity][actionState] = imagePath;
      console.log(
        '[ACTION UPLOAD DEBUG] New action_images config:',
        JSON.stringify(newConfig.action_images)
      );

      // Update the config
      this._updateConfig(newConfig);
      console.log('[ACTION UPLOAD DEBUG] Config updated successfully');
    } catch (error) {
      console.error('[ACTION UPLOAD DEBUG] Error during upload process:', error);
      alert(
        'Failed to upload image. Please try again or upload the image manually to the Media Library.'
      );
    }
  }

  private _handleImageError(e: Event) {
    const img = e.target as HTMLImageElement;
    const originalSrc = img.src;

    console.error('[IMAGE ERROR] Failed to load image:', originalSrc);

    // Show a notification with the issue
    this._showNotification(
      `Failed to load image from: ${originalSrc.substring(0, 50)}${originalSrc.length > 50 ? '...' : ''}`,
      'warning'
    );

    // Check if the image is already the default to prevent infinite error loop
    if (originalSrc.includes('car-default.png') || originalSrc.includes('car-uploaded.png')) {
      console.warn(
        '[IMAGE ERROR] Already using a default image, not replacing to avoid error loop'
      );
      return;
    }

    // Set to default image
    img.src = DEFAULT_VEHICLE_IMAGE;
    console.info('[IMAGE ERROR] Replaced with default image:', DEFAULT_VEHICLE_IMAGE);

    // Add an error class to the parent for styling
    if (img.parentElement) {
      img.parentElement.classList.add('image-error');
    }
  }

  private _renderActionImage() {
    let actionImageUrl = '';
    console.log('[RENDER DEBUG] Starting _renderActionImage method');

    // Check if we should display an action image
    if (
      this.config.action_entity &&
      this.config.action_state &&
      this.hass.states[this.config.action_entity]?.state === this.config.action_state &&
      this.config.action_images?.[this.config.action_entity]?.[this.config.action_state]
    ) {
      // Use the action image for the current state
      const imagePath =
        this.config.action_images[this.config.action_entity][this.config.action_state];
      console.log('[RENDER DEBUG] Using action image path:', imagePath);

      // Check if it's a base64 image (legacy)
      if (imagePath && imagePath.startsWith('data:image/')) {
        console.log('[RENDER DEBUG] Legacy: Using base64 action image');
        actionImageUrl = imagePath;
      } else if (imagePath) {
        // Handle HA API uploaded image paths
        actionImageUrl = this._buildHassUrl(imagePath);
        console.log('[RENDER DEBUG] Constructed action image URL:', actionImageUrl);
      }
    }
    // If no action image is applicable, use the standard vehicle image
    else {
      // Handle the different image type options - using the same pattern as _renderImage()
      const imageType = this.config.action_image_type;
      console.log('[RENDER DEBUG] Action image type:', imageType);

      // Instead of direct comparison to 'default', use a safer approach with conditionals
      if (imageType === 'upload') {
        // Upload image type uses HA image API paths
        const imagePath = this.config.action_image || '';
        console.log('[RENDER DEBUG] Action image path:', imagePath);

        // Check if it's a base64 image (legacy)
        if (imagePath && imagePath.startsWith('data:image/')) {
          console.log('[RENDER DEBUG] Legacy: Using base64 action image');
          actionImageUrl = imagePath;
        } else if (imagePath) {
          // Handle HA API uploaded image paths
          actionImageUrl = this._buildHassUrl(imagePath);
          console.log('[RENDER DEBUG] Constructed action image URL:', actionImageUrl);
        }
      } else if (imageType === 'url') {
        actionImageUrl = this.config.action_image || '';
        console.log('[RENDER DEBUG] URL image type, using direct URL:', actionImageUrl);
      } else if (imageType === 'entity' && this.config.action_image_entity) {
        const entityState = this.hass.states[this.config.action_image_entity]?.state || '';
        console.log('[RENDER DEBUG] Entity image type, entity state:', entityState);
        actionImageUrl = entityState;
      } else if (imageType !== 'none') {
        // Default behavior for any other value (including 'default')
        console.log('[RENDER DEBUG] Using default action image:', DEFAULT_VEHICLE_IMAGE);
        actionImageUrl = DEFAULT_VEHICLE_IMAGE;
      }
    }

    // If no image URL is determined but we're not explicitly set to 'none', use default
    if (!actionImageUrl && this.config.action_image_type !== 'none') {
      console.log('[RENDER DEBUG] No action image URL determined, falling back to default');
      actionImageUrl = DEFAULT_VEHICLE_IMAGE;
    }

    console.log('[RENDER DEBUG] Final action image URL to be rendered:', actionImageUrl);

    if (!actionImageUrl) {
      console.log('[RENDER DEBUG] No action image URL available, returning empty string');
      return '';
    }

    // Apply width style if specified
    let imageStyle =
      this.config.action_image_width !== undefined
        ? `width: ${this.config.action_image_width}%; height: auto;`
        : '';

    console.log('[RENDER DEBUG] Action image style:', imageStyle);

    // Apply crop if specified
    if (this.config.action_image_crop) {
      const crop = this.config.action_image_crop;
      imageStyle += ` margin: ${crop.top}% ${crop.right}% ${crop.bottom}% ${crop.left}%;
                     max-width: calc(100% - ${crop.left}% - ${crop.right}%);
                     max-height: calc(100% - ${crop.top}% - ${crop.bottom}%);`;
      console.log('[RENDER DEBUG] Action image crop applied:', crop);
    }

    console.log('[RENDER DEBUG] Returning action image HTML with URL:', actionImageUrl);
    return html`
      <div class="action-image-container">
        <img
          src="${actionImageUrl}"
          alt="Vehicle Action"
          style="${imageStyle}"
          class="action-image"
          @error=${this._handleImageError}
        />
      </div>
    `;
  }

  private _formatValue(value: string, entityId?: string): string {
    if (!entityId || !this.hass.states[entityId]) return value;

    // Log to help debug
    console.log(
      `[FORMAT] Formatting value "${value}" for entity "${entityId}" with formatted_entities=${this.config.formatted_entities}`
    );

    // If formatted_entities is disabled, return the raw value
    if (!this.config.formatted_entities) {
      console.log('[FORMAT] Formatted entities disabled, returning raw value');
      return value;
    }

    // Check if this is a mileage entity
    if (entityId === this.config.mileage_entity) {
      // Format mileage to remove decimal places and add appropriate unit
      const numValue = parseFloat(value);
      if (!isNaN(numValue)) {
        const roundedValue = Math.round(numValue);
        // Get the unit from the entity's attributes if available
        const unit = this.hass.states[entityId]?.attributes?.unit_of_measurement || '';
        const formatted = `${roundedValue.toLocaleString()}${unit ? ' ' + unit : ''}`;
        console.log(`[FORMAT] Formatted mileage value: ${formatted}`);
        return formatted;
      }
    }

    // Check if this is a location entity
    if (entityId === this.config.location_entity) {
      // Check if this location matches any zone entity
      const zoneEntities = Object.keys(this.hass.states).filter(id => id.startsWith('zone.'));

      for (const zoneId of zoneEntities) {
        const zone = this.hass.states[zoneId];
        // If zone has latitude/longitude attributes and the location entity has the same
        const locationState = this.hass.states[entityId];

        if (
          zone &&
          locationState &&
          zone.attributes.latitude &&
          zone.attributes.longitude &&
          locationState.attributes &&
          locationState.attributes.latitude &&
          locationState.attributes.longitude
        ) {
          // Simple check if they're close (for exact matching you'd need distance calculation)
          if (
            Math.abs(zone.attributes.latitude - locationState.attributes.latitude) < 0.0001 &&
            Math.abs(zone.attributes.longitude - locationState.attributes.longitude) < 0.0001
          ) {
            // Return zone friendly name
            const zoneName =
              zone.attributes.friendly_name || zone.attributes.name || zoneId.split('.')[1];
            console.log(`[FORMAT] Found matching zone: ${zoneName}`);
            return zoneName;
          }
        }
      }

      // If no zone matched, check if there's a formatted address
      if (this.hass.states[entityId]?.attributes?.formatted_address) {
        const address = this.hass.states[entityId].attributes.formatted_address;
        console.log(`[FORMAT] Using formatted address: ${address}`);
        return address;
      }
    }

    // Format numbers with unit of measurement for any entity
    const numValue = parseFloat(value);
    if (!isNaN(numValue)) {
      // Format with thousand separators and unit
      const unit = this.hass.states[entityId]?.attributes?.unit_of_measurement || '';
      let formattedNum;

      // If it's a whole number or large number, round it
      if (numValue % 1 === 0 || Math.abs(numValue) >= 1000) {
        formattedNum = Math.round(numValue).toLocaleString();
      } else {
        // Otherwise keep decimal places
        formattedNum = numValue.toLocaleString('en-US', {
          maximumFractionDigits: 2,
          minimumFractionDigits: 0,
        });
      }

      const formatted = `${formattedNum}${unit ? ' ' + unit : ''}`;
      console.log(`[FORMAT] Formatted numeric value: ${formatted}`);
      return formatted;
    }

    // Format text values - capitalize words and replace underscores with spaces
    const formatted = value.replace(/_/g, ' ').replace(/\b\w/g, l => l.toUpperCase());

    console.log(`[FORMAT] Formatted text value: ${formatted}`);
    return formatted;
  }

  private _renderBar(bar: any) {
    // Log the current bar config for debugging
    console.log('[DEBUG] _renderBar called with bar:', JSON.stringify(bar));

    // Log a warning if bar is missing critical properties
    if (!bar || !bar.entity) {
      console.warn('[DEBUG] Invalid bar configuration (missing entity):', bar);
      return html`
        <div style="color: red; padding: 8px; border: 1px solid red; margin: 8px 0;">
          Invalid bar configuration: missing entity
        </div>
      `;
    }

    // Get entity state and convert to percentage
    const entityState = this.hass.states[bar.entity];
    if (!entityState) {
      console.warn(`[DEBUG] Bar entity not found: ${bar.entity}`);
      return html`
        <div style="color: red; padding: 8px; border: 1px solid red; margin: 8px 0;">
          Entity not found: ${bar.entity}
        </div>
      `;
    }

    const value = entityState.state;
    const numValue = parseFloat(value);
    const percentage = !isNaN(numValue) ? Math.min(100, Math.max(0, numValue)) : 0;

    console.log(
      `[DEBUG] _renderBar processing entity ${bar.entity} with value ${value} (${percentage}%)`
    );

    // Get limit value if available
    const limitValue = bar.limit_entity ? this.hass.states[bar.limit_entity]?.state : null;
    const limitPercentage =
      limitValue && !isNaN(parseFloat(limitValue))
        ? Math.min(100, Math.max(0, parseFloat(limitValue)))
        : null;

    // Get left and right entity values
    const leftValue =
      bar.show_left !== false && bar.left_entity
        ? this._formatValue(this.hass.states[bar.left_entity]?.state, bar.left_entity)
        : '';

    const rightValue =
      bar.show_right !== false && bar.right_entity
        ? this._formatValue(this.hass.states[bar.right_entity]?.state, bar.right_entity)
        : '';

    console.log(`[DEBUG] Bar labels: left=${leftValue}, right=${rightValue}`);

    // Format colors to ensure they're proper CSS values
    const formatColor = (color: any) => {
      // If color is null or undefined, return default
      if (color == null) return '';

      // If it's an array of RGB values
      if (Array.isArray(color)) {
        return `rgb(${color.join(', ')})`;
      }

      // If it's an object with r, g, b properties
      if (typeof color === 'object' && 'r' in color && 'g' in color && 'b' in color) {
        return `rgb(${color.r}, ${color.g}, ${color.b})`;
      }

      // Now we know it's a string or can be converted to string
      const colorStr = String(color);

      // If it's already a proper CSS color format (hex, rgb, etc.), return as is
      if (
        colorStr.startsWith('#') ||
        colorStr.startsWith('rgb') ||
        colorStr.startsWith('hsl') ||
        colorStr.startsWith('var(')
      ) {
        return colorStr;
      }

      // If it's a comma-separated list of numbers, wrap with rgb()
      if (/^\d+\s*,\s*\d+\s*,\s*\d+$/.test(colorStr)) {
        return `rgb(${colorStr})`;
      }

      return colorStr;
    };

    // Default colors
    const barColor = formatColor(bar.bar_color || '#3498db');
    const bgColor = formatColor(bar.background_color || '#e0e0e0');
    const borderColor = formatColor(bar.border_color || '#cccccc');
    const leftTextColor = formatColor(bar.left_text_color || 'var(--text-primary-color)');
    const rightTextColor = formatColor(bar.right_text_color || 'var(--text-primary-color)');
    const leftTitleColor = formatColor(bar.left_title_color || 'var(--text-primary-color)');
    const rightTitleColor = formatColor(bar.right_title_color || 'var(--text-primary-color)');
    const limitIndicatorColor = formatColor(bar.limit_indicator_color || '#ff0000');

    // Get bar size
    const barSize = bar.bar_size || 'regular';
    const barHeightClass = `bar-size-${barSize}`;

    // Determine label alignment
    const labelAlignment = bar.alignment || 'space-between';

    // Handle bar width (default to 100% if not specified)
    const barWidth = bar.width || '100';

    // Get friendly names for titles if not explicitly set
    const getFriendlyName = entityId => {
      if (!entityId || !this.hass.states[entityId]) return '';
      return (
        this.hass.states[entityId]?.attributes?.friendly_name || entityId.split('.').pop() || ''
      );
    };

    // Truncate text to keep layout consistent
    const truncateText = (text, maxLength = 15) => {
      if (!text) return '';
      if (text.length <= maxLength) return text;
      return text.substring(0, maxLength) + '...';
    };

    // Use friendly name for left title if not set
    const leftTitle =
      bar.left_title ||
      (bar.show_left !== false && bar.left_entity ? getFriendlyName(bar.left_entity) : '');

    // Use friendly name for right title if not set
    const rightTitle =
      bar.right_title ||
      (bar.show_right !== false && bar.right_entity ? getFriendlyName(bar.right_entity) : '');

    // Prepare bar fill style including gradient if enabled
    let barFillStyle = `width: ${percentage}%;`;

    console.log(
      `[DEBUG] Rendering bar with width: ${barWidth}%, percentage: ${percentage}%, size: ${barSize}`
    );

    if (bar.use_gradient && bar.gradient_stops && bar.gradient_stops.length >= 2) {
      // Sort gradient stops by position
      const sortedStops = [...bar.gradient_stops].sort((a, b) => a.position - b.position);

      // Find the color at the current percentage
      let currentColor;

      // If percentage is exactly at a stop position, use that color
      const exactStop = sortedStops.find(stop => stop.position === percentage);
      if (exactStop) {
        currentColor = formatColor(exactStop.color);
      } else {
        // Find the stops that the current percentage falls between
        let lowerStop = sortedStops[0];
        let upperStop = sortedStops[sortedStops.length - 1];

        for (let i = 0; i < sortedStops.length - 1; i++) {
          if (percentage >= sortedStops[i].position && percentage <= sortedStops[i + 1].position) {
            lowerStop = sortedStops[i];
            upperStop = sortedStops[i + 1];
            break;
          }
        }

        // Calculate the interpolated color
        if (lowerStop === upperStop) {
          currentColor = formatColor(lowerStop.color);
        } else {
          // Calculate the percentage between the two stops
          const positionRange = upperStop.position - lowerStop.position;
          const positionPercentage =
            positionRange === 0 ? 0 : (percentage - lowerStop.position) / positionRange;

          // Convert colors to RGB to interpolate
          const lowerColor = this._hexToRgb(lowerStop.color);
          const upperColor = this._hexToRgb(upperStop.color);

          if (lowerColor && upperColor) {
            // Interpolate RGB values
            const r = Math.round(lowerColor.r + positionPercentage * (upperColor.r - lowerColor.r));
            const g = Math.round(lowerColor.g + positionPercentage * (upperColor.g - lowerColor.g));
            const b = Math.round(lowerColor.b + positionPercentage * (upperColor.b - lowerColor.b));

            currentColor = `rgb(${r}, ${g}, ${b})`;
          } else {
            // Fallback if colors can't be parsed
            currentColor = formatColor(lowerStop.color);
          }
        }
      }

      barFillStyle += `background-color: ${currentColor};`;
      console.log('[DEBUG] Using gradient color at position', percentage, ':', currentColor);
    } else {
      barFillStyle += `background-color: ${barColor};`;
      if (bar.use_gradient) {
        console.log('[DEBUG] Gradient enabled but stops missing for bar:', bar.entity);
      }
    }

    // Check if animation should be active
    let animationClass = '';
    let animationStyle = '';
    let needsAnimation = false;

    if (
      bar.action_animation_entity &&
      bar.action_animation_state &&
      bar.action_animation &&
      bar.action_animation !== 'none'
    ) {
      // Get the entity state
      const animationEntityState = this.hass.states[bar.action_animation_entity]?.state;

      // Log complete details for debugging
      console.log(
        `[ANIMATION DEBUG] Checking animation for bar: ${bar.entity}
        - Animation entity: ${bar.action_animation_entity}
        - Current state: ${animationEntityState}
        - Target state: ${bar.action_animation_state}
        - Animation type: ${bar.action_animation}
        - State match: ${animationEntityState?.toLowerCase() === bar.action_animation_state?.toLowerCase() ? 'YES' : 'NO'}`
      );

      // If the entity state matches the animation state, apply animation
      if (
        animationEntityState &&
        bar.action_animation_state &&
        animationEntityState.toLowerCase() === bar.action_animation_state.toLowerCase()
      ) {
        animationClass = `animation-${bar.action_animation}`;
        needsAnimation = true;

        // Add special animation overrides for certain types
        if (bar.action_animation === 'filling') {
          // Override the width property with important flag for the filling animation
          animationStyle = 'width: auto !important;';
        }

        // For charging animation, force the background image
        if (bar.action_animation === 'charging') {
          animationStyle += `
            background-image: linear-gradient(-45deg, rgba(255,255,255,0.5) 25%, transparent 25%, 
            transparent 50%, rgba(255,255,255,0.5) 50%, rgba(255,255,255,0.5) 75%, 
            transparent 75%, transparent) !important;
            background-size: 30px 30px !important;
          `;
        }

        console.log(
          `[ANIMATION DEBUG] ✅ Applying animation: ${animationClass} to bar ${bar.entity}`
        );
      } else {
        console.log(`[ANIMATION DEBUG] ❌ No animation applied - states don't match`);
      }
    } else {
      console.log(
        `[ANIMATION DEBUG] Animation not configured for bar ${bar.entity}:
        - Has entity: ${bar.action_animation_entity ? 'YES' : 'NO'} (${bar.action_animation_entity || 'none'})
        - Has state: ${bar.action_animation_state ? 'YES' : 'NO'} (${bar.action_animation_state || 'none'})
        - Has animation: ${bar.action_animation ? 'YES' : 'NO'} (${bar.action_animation || 'none'})`
      );
    }

    // Set animation-specific ID to help with direct targeting
    const barId = `bar-${bar.entity.replace(/\./g, '-')}-${Date.now()}`;

    // Create animation-specific data attributes that will be used by the animation injector
    const animationDataAttributes = {
      'data-entity': bar.entity,
      'data-animation-entity': bar.action_animation_entity || '',
      'data-animation-state': bar.action_animation_state || '',
      'data-animation-type': bar.action_animation || 'none',
      'data-needs-animation': needsAnimation ? 'true' : 'false',
      'data-bar-id': barId,
      'data-percentage': percentage.toString(),
    };

    console.log(`[ANIMATION DEBUG] Bar ${barId} animation attributes:`, animationDataAttributes);

    const result = html`
      <div
        class="progress-bar-container"
        style="width: ${barWidth}%; min-width: ${barWidth < 100 ? '200px' : '100%'};"
        id="${barId}"
        data-entity="${bar.entity}"
        data-animation-entity="${bar.action_animation_entity || ''}"
        data-animation-state="${bar.action_animation_state || ''}"
        data-animation-type="${bar.action_animation || 'none'}"
        data-needs-animation="${needsAnimation ? 'true' : 'false'}"
        data-bar-id="${barId}"
        data-percentage="${percentage.toString()}"
      >
        <div
          class="progress-bar ${barHeightClass}"
          style="border-color: ${borderColor}; background-color: ${bgColor};"
        >
          <div
            class="progress-bar-fill ${animationClass}"
            style="${barFillStyle} ${animationStyle}"
            data-animation="${animationClass}"
            data-animated="${needsAnimation ? 'true' : 'false'}"
          ></div>
          ${limitPercentage !== null
            ? html`
                <div
                  class="limit-indicator"
                  style="left: ${limitPercentage}%; background-color: ${limitIndicatorColor};"
                ></div>
              `
            : ''}
        </div>

        <div class="bar-labels" style="justify-content: ${labelAlignment};">
          ${bar.show_left !== false
            ? html`
                <div class="bar-label left">
                  ${leftTitle
                    ? html`<span class="label-title" style="color: ${leftTitleColor}"
                        >${truncateText(leftTitle)}:</span
                      >`
                    : ''}
                  ${leftValue
                    ? html`<span class="label-value" style="color: ${leftTextColor}"
                        >${leftValue}</span
                      >`
                    : ''}
                </div>
              `
            : ''}
          ${bar.show_right !== false
            ? html`
                <div class="bar-label right">
                  ${rightTitle
                    ? html`<span class="label-title" style="color: ${rightTitleColor}"
                        >${truncateText(rightTitle)}:</span
                      >`
                    : ''}
                  ${rightValue
                    ? html`<span class="label-value" style="color: ${rightTextColor}"
                        >${rightValue}</span
                      >`
                    : ''}
                </div>
              `
            : ''}
        </div>
      </div>
    `;

    console.log(`[ANIMATION DEBUG] Bar render complete for ${barId}`);
    return result;
  }

  private _renderIconRows() {
    const { icon_rows = [] } = this.config;

    if (!icon_rows || icon_rows.length === 0) return html``;

    return html`
      <div class="icon-rows-container">${icon_rows.map(row => this._renderIconRow(row))}</div>
    `;
  }

  private _renderIconRow(row: IconRowConfig) {
    if (!row || !row.icons || !row.icons.length) return html``;

    // Get the width as a number (with fallback to 100)
    const width = parseInt(row.width || '100', 10);

    // Get alignment (with fallback to space-between)
    const alignment = row.alignment || 'space-between';

    // Set spacing based on configuration
    const spacing = row.spacing || 'none';
    const spacingMap = {
      none: '0',
      small: '4px',
      medium: '8px',
      large: '16px',
    };
    const spacingPx = spacingMap[spacing];

    return html`
      <div
        class="icon-row"
        style="width: ${width}%; gap: ${spacingPx};"
        data-alignment="${alignment}"
        data-spacing="${spacing}"
      >
        ${row.icons.map(icon => this._renderCardIcon(icon))}
      </div>
    `;
  }

  private _renderCardIcon(icon: IconConfig) {
    if (!icon.entity) return html``;

    const state = this.hass.states[icon.entity];
    if (!state) return html``;

    // Get configuration values with defaults
    const textPosition = icon.text_position || 'bottom';
    const verticalAlignment = icon.vertical_alignment || 'center';
    const iconSize = icon.icon_size || 'medium';
    const textSize = icon.text_size || 'medium';

    // Determine if icon is active
    const isActive = icon.active_state
      ? state.state === icon.active_state
      : state.state !== (icon.inactive_state || 'off');

    // Get icon and color based on state
    const displayIcon = isActive && icon.icon_active ? icon.icon_active : icon.icon_inactive;
    const displayColor = isActive && icon.color_active ? icon.color_active : icon.color_inactive;

    // Get display name and state
    const displayName = icon.name || state.attributes.friendly_name || '';
    let displayState = state.state;
    const unit = state.attributes.unit_of_measurement;

    // Format state if formatted_entities is enabled
    if (this.config.formatted_entities && displayState) {
      // Format numeric values
      if (!isNaN(Number(displayState))) {
        const numValue = Number(displayState);
        if (Math.abs(numValue) >= 1000 || numValue % 1 !== 0) {
          displayState = numValue.toLocaleString('en-US', {
            maximumFractionDigits: 2,
            minimumFractionDigits: 0,
          });
        }
      } else {
        // Format text values
        displayState = displayState
          .replace(/_/g, ' ')
          .replace(/\b\w/g, match => match.toUpperCase());
      }
    }

    // Add unit/currency if needed
    if (displayState && icon.show_state) {
      const prefix = state.attributes.prefix || '';
      const suffix = state.attributes.suffix || '';

      if (unit && icon.show_units) {
        displayState = `${displayState} ${unit}`;
      }

      displayState = `${prefix}${displayState}${suffix}`;
    }

    // Generate CSS classes
    const positionClass = `position-${textPosition}`;
    const alignmentClass = `align-${
      verticalAlignment === 'flex-start'
        ? 'top'
        : verticalAlignment === 'flex-end'
          ? 'bottom'
          : 'center'
    }`;
    const iconSizeClass = `icon-size-${iconSize}`;
    const textSizeClass = `icon-text-${textSize}`;

    // Combine the CSS classes
    const containerClasses = `icon-container ${positionClass} ${alignmentClass} ${iconSizeClass} ${textSizeClass}`;

    // The minimum width depends on the text position
    const minWidth = textPosition === 'left' || textPosition === 'right' ? '120px' : '60px';

    return html`
      <div
        class="${containerClasses}"
        @click=${() => this._handleIconClick(icon)}
        style="min-width: ${minWidth};"
        data-text-position="${textPosition}"
        data-vertical-alignment="${verticalAlignment}"
        data-icon-size="${iconSize}"
        data-text-size="${textSize}"
      >
        <ha-icon
          .icon="${displayIcon || 'mdi:help-circle-outline'}"
          style="color: ${displayColor || 'var(--primary-text-color)'};"
        ></ha-icon>
        <div class="icon-text-container">
          ${icon.show_name !== false ? html`<div class="icon-label">${displayName}</div>` : ''}
          ${icon.show_state ? html`<div class="icon-state">${displayState}</div>` : ''}
        </div>
      </div>
    `;
  }

  private _handleIconClick(icon: IconConfig) {
    if (!icon.entity || !icon.on_click_action) return;

    switch (icon.on_click_action) {
      case 'toggle':
        const domain = icon.entity.split('.')[0];
        this.hass.callService(domain, 'toggle', { entity_id: icon.entity });
        break;
      case 'more-info':
        const event = new CustomEvent('hass-more-info', {
          detail: { entityId: icon.entity },
          bubbles: true,
          composed: true,
        });
        this.dispatchEvent(event);
        break;
      // Add more actions if needed
    }
  }

  private _hexToRgb(colorValue: string) {
    // Handle hex colors
    if (colorValue.startsWith('#')) {
      // Convert short hex format (#rgb) to full format (#rrggbb)
      let hex = colorValue;
      if (hex.length === 4) {
        hex = '#' + hex[1] + hex[1] + hex[2] + hex[2] + hex[3] + hex[3];
      }

      // Standard hex #rrggbb format
      if (hex.length === 7) {
        const r = parseInt(hex.slice(1, 3), 16);
        const g = parseInt(hex.slice(3, 5), 16);
        const b = parseInt(hex.slice(5, 7), 16);
        return { r, g, b };
      }
    }

    // Handle rgb() format
    if (colorValue.startsWith('rgb')) {
      const rgbMatch = colorValue.match(/rgb\(\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*\)/);
      if (rgbMatch) {
        return {
          r: parseInt(rgbMatch[1], 10),
          g: parseInt(rgbMatch[2], 10),
          b: parseInt(rgbMatch[3], 10),
        };
      }
    }

    // Default fallback color (gray)
    return { r: 128, g: 128, b: 128 };
  }

  private _renderVehicleInfo() {
    // Check if any info should be displayed
    const showLocation =
      this.config.show_location !== false &&
      this.config.location_entity &&
      this.hass.states[this.config.location_entity] !== undefined;

    const showMileage =
      this.config.show_mileage !== false &&
      this.config.mileage_entity &&
      this.hass.states[this.config.mileage_entity] !== undefined;

    const showCarState =
      this.config.show_car_state !== false &&
      this.config.car_state_entity &&
      this.hass.states[this.config.car_state_entity] !== undefined;

    // If nothing to show, return empty
    if (!showLocation && !showMileage && !showCarState) {
      return html``;
    }

    // Get the values
    const locationValue = showLocation
      ? this._formatValue(
          this.hass.states[this.config.location_entity!].state,
          this.config.location_entity
        )
      : '';

    const mileageValue = showMileage
      ? this._formatValue(
          this.hass.states[this.config.mileage_entity!].state,
          this.config.mileage_entity
        )
      : '';

    const carStateValue = showCarState
      ? this._formatValue(
          this.hass.states[this.config.car_state_entity!].state,
          this.config.car_state_entity
        )
      : '';

    return html`
      <div class="vehicle-info-container">
        <div class="vehicle-info-top">
          ${showLocation
            ? html`
                <div class="info-item-with-icon">
                  <ha-icon icon="mdi:map-marker"></ha-icon>
                  <span>${locationValue}</span>
                </div>
              `
            : ''}
          ${showMileage
            ? html`
                <div class="info-item-with-icon">
                  <ha-icon icon="mdi:speedometer"></ha-icon>
                  <span>${mileageValue}</span>
                </div>
              `
            : ''}
        </div>

        ${showCarState
          ? html`
              <div class="info-item-status">
                <span>${carStateValue}</span>
              </div>
            `
          : ''}
      </div>
    `;
  }

  /**
   * Update the configuration and trigger a refresh
   */
  private _updateConfig(newConfig: Partial<UltraVehicleCardConfig>) {
    // Update the config
    this.config = {
      ...this.config,
      ...newConfig,
    };

    console.log('[CONFIG UPDATE] Config updated:', JSON.stringify(newConfig));

    // Force the component to re-render by setting a configuration flag
    this._cardVersion = `${this._cardVersion}-${Date.now()}`;

    // Use the new _forceRender method to ensure proper rendering
    this._forceRender();
  }

  /**
   * Called when the element is connected to the DOM
   */
  connectedCallback() {
    super.connectedCallback();
    console.log('[LIFECYCLE] Card connected to DOM with version:', this._cardVersion);

    // Force style application on connection
    this._scheduleStylesUpdate();

    // Force animation updates
    this._scheduleAnimationUpdate();
  }

  /**
   * Schedule style updates to run after rendering
   */
  private _scheduleStylesUpdate() {
    // Apply styles immediately
    setTimeout(() => {
      this._applyForcedStyles();
    }, 100);

    // And again after a longer delay to catch any slow-rendering elements
    setTimeout(() => {
      this._applyForcedStyles();
    }, 500);

    // And one more time after an even longer delay
    setTimeout(() => {
      this._applyForcedStyles();
    }, 1000);
  }

  /**
   * Called when properties are updated
   */
  updated(changedProperties) {
    super.updated(changedProperties);
    console.log('[LIFECYCLE] Card updated');

    // Check if config was changed
    if (changedProperties.has('config')) {
      console.log('[LIFECYCLE] Config was updated, forcing style reapplication');
      this._scheduleStylesUpdate();
      this._scheduleAnimationUpdate();
    } else {
      // Force style application after any update
      this._scheduleStylesUpdate();
      this._scheduleAnimationUpdate();
    }
  }

  /**
   * Force the component to re-render
   */
  private _forceRender() {
    console.log('[RENDER] Forcing re-render');

    // Trick for browser to actually re-render
    this.style.display = 'none';

    // Use requestAnimationFrame to ensure we're in the next render cycle
    requestAnimationFrame(() => {
      this.style.display = 'block';
      this.requestUpdate();

      // Apply styles after re-render
      this._scheduleStylesUpdate();
    });
  }

  /**
   * Force application of styles to override any CSS inheritance issues
   */
  private _applyForcedStyles() {
    console.log('[STYLES] Forcing application of custom styles');

    try {
      // Find all icon rows by data attribute
      const iconRows = this.renderRoot.querySelectorAll('.icon-row');
      console.log(`[STYLES] Found ${iconRows.length} icon rows to style`);

      iconRows.forEach((rowElement: Element) => {
        // Ensure we're working with an HTMLElement
        const row = rowElement as HTMLElement;
        const alignment = row.dataset.alignment || 'space-between';
        console.log(`[STYLES] Applying alignment ${alignment} to row`);

        // Force the alignment with !important to override any other styles
        row.style.setProperty('justify-content', alignment, 'important');
        row.style.setProperty('display', 'flex', 'important');
        row.style.setProperty('flex-wrap', 'wrap', 'important');

        // Also add a class to help with styling
        row.classList.add(`align-${alignment}`);

        // Find all icons in this row
        const icons = row.querySelectorAll('.icon-container');
        console.log(`[STYLES] Found ${icons.length} icons in row to style`);

        icons.forEach((iconElement: Element) => {
          // Ensure we're working with an HTMLElement
          const icon = iconElement as HTMLElement;
          const position = icon.dataset.textPosition || 'bottom';
          const alignment = icon.dataset.verticalAlignment || 'center';
          const iconSize = icon.dataset.iconSize || 'medium';
          const textSize = icon.dataset.textSize || 'medium';

          console.log(
            `[STYLES] Applying position ${position}, alignment ${alignment}, icon size ${iconSize}, text size ${textSize} to icon`
          );

          // Add classes for CSS to target
          icon.classList.add(`position-${position}`);
          icon.classList.add(
            `align-${alignment === 'flex-start' ? 'top' : alignment === 'flex-end' ? 'bottom' : 'center'}`
          );
          icon.classList.add(`icon-size-${iconSize}`);
          icon.classList.add(`icon-text-${textSize}`);

          // Apply direct styles to ensure they're applied
          const flexDirection =
            {
              bottom: 'column',
              top: 'column-reverse',
              left: 'row-reverse',
              right: 'row',
            }[position] || 'column';

          // Force styles with !important to override any other styles
          icon.style.setProperty('flex-direction', flexDirection, 'important');
          icon.style.setProperty('align-items', alignment, 'important');

          // Apply text alignment based on position
          const textContainer = icon.querySelector('.icon-text-container');
          if (textContainer && textContainer instanceof HTMLElement) {
            if (position === 'left' || position === 'right') {
              textContainer.style.setProperty('text-align', 'left', 'important');
              textContainer.style.setProperty('align-items', 'flex-start', 'important');
              textContainer.style.setProperty('min-width', '80px', 'important');
            } else {
              textContainer.style.setProperty('text-align', 'center', 'important');
              textContainer.style.setProperty('align-items', 'center', 'important');
              textContainer.style.setProperty('width', '100%', 'important');
            }

            // Apply text size
            const fontSize =
              {
                small: '0.8em',
                medium: '0.9em',
                large: '1.1em',
              }[textSize] || '0.9em';

            textContainer.style.setProperty('font-size', fontSize, 'important');
          }

          // Set icon size directly on the ha-icon element
          const iconEl = icon.querySelector('ha-icon');
          if (iconEl && iconEl instanceof HTMLElement) {
            const pixelSize =
              {
                small: '20px',
                medium: '24px',
                large: '32px',
              }[iconSize] || '24px';

            iconEl.style.setProperty('--mdc-icon-size', pixelSize, 'important');
            iconEl.style.setProperty('font-size', pixelSize, 'important');
          }
        });
      });

      console.log('[STYLES] Forced styles applied successfully');
    } catch (e) {
      console.error('[STYLES] Error applying forced styles:', e);
    }
  }

  /**
   * Schedule animation updates to run after rendering
   */
  private _scheduleAnimationUpdate() {
    console.log('[ANIMATION] Scheduling animation updates');

    // Apply animations soon after rendering
    setTimeout(() => this._forceApplyAnimations(), 100);

    // And again after longer delays to catch any slow-rendering elements
    setTimeout(() => this._forceApplyAnimations(), 500);
    setTimeout(() => this._forceApplyAnimations(), 1000);
  }

  /**
   * Force application of animations by directly manipulating the DOM
   */
  private _forceApplyAnimations() {
    try {
      console.log('[ANIMATION] Directly applying animations to DOM');

      // Find all animation containers within this card
      const containers = this.renderRoot.querySelectorAll(
        '.progress-bar-container[data-animation-entity]'
      );
      console.log(`[ANIMATION] Found ${containers.length} animation containers`);

      containers.forEach((container: Element) => {
        // Skip containers without required data
        if (!(container instanceof HTMLElement)) return;

        const animEntity = container.dataset.animationEntity;
        const animState = container.dataset.animationState;
        const animType = container.dataset.animationType;
        const needsAnimation = container.dataset.needsAnimation === 'true';

        if (!animEntity || !animState || !animType || animType === 'none') {
          console.log('[ANIMATION] Container missing required data:', container.id);
          return;
        }

        // Get the current entity state from hass
        const entityState = this.hass.states[animEntity]?.state;
        const stateMatches = entityState && entityState.toLowerCase() === animState.toLowerCase();

        console.log(
          `[ANIMATION] Container ${container.id}: entity=${animEntity}, currentState=${entityState}, targetState=${animState}, type=${animType}, matches=${stateMatches}`
        );

        // Find the fill element
        const fillElement = container.querySelector('.progress-bar-fill');
        if (!fillElement || !(fillElement instanceof HTMLElement)) {
          console.log('[ANIMATION] No fill element found in container', container.id);
          return;
        }

        // Apply or remove animation based on state
        if (stateMatches) {
          console.log(`[ANIMATION] Applying ${animType} animation to ${container.id}`);

          // Add the animation class
          fillElement.classList.add(`animation-${animType}`);

          // Apply styles directly for maximum compatibility
          if (animType === 'charging') {
            fillElement.style.backgroundImage =
              'linear-gradient(-45deg, rgba(255,255,255,0.5) 25%, transparent 25%, transparent 50%, rgba(255,255,255,0.5) 50%, rgba(255,255,255,0.5) 75%, transparent 75%, transparent)';
            fillElement.style.backgroundSize = '30px 30px';
            fillElement.style.animation = 'cardChargingAnimation 1s linear infinite';
          } else if (animType === 'filling') {
            fillElement.style.width = 'auto';
            fillElement.style.animation = 'cardFillingAnimation 3s ease-in-out infinite alternate';
          } else if (animType === 'pulsing') {
            fillElement.style.animation = 'cardPulsingAnimation 1.5s ease-in-out infinite';
          } else if (animType === 'blinking') {
            fillElement.style.animation = 'cardBlinkingAnimation 1s step-end infinite';
          } else if (animType === 'bouncing') {
            fillElement.style.animation = 'cardBouncingAnimation 0.8s ease-in-out infinite';
            fillElement.style.transformOrigin = 'center';
          }

          // Set high z-index to ensure it's visible
          fillElement.style.zIndex = '100';
        } else {
          console.log(`[ANIMATION] Removing animations from ${container.id}`);

          // Remove all animation classes
          fillElement.classList.remove(
            'animation-charging',
            'animation-filling',
            'animation-pulsing',
            'animation-blinking',
            'animation-bouncing'
          );

          // Clear animation-related styles
          fillElement.style.animation = '';
          // Only clear backgroundImage if it was set by our animations
          if (fillElement.style.backgroundImage.includes('linear-gradient(-45deg')) {
            fillElement.style.backgroundImage = '';
          }
        }
      });

      console.log('[ANIMATION] Direct animation application complete');
    } catch (error) {
      console.error('[ANIMATION] Error applying animations:', error);
    }
  }
}
